<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ruby on Day Day Up</title><link>/techBlog/tags/ruby/</link><description>Recent content in ruby on Day Day Up</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 07 Mar 2021 21:22:31 +0900</lastBuildDate><atom:link href="/techBlog/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>Ruby_on_rails_tips</title><link>/techBlog/posts/ruby_on_rails_tips/</link><pubDate>Sun, 07 Mar 2021 21:22:31 +0900</pubDate><guid>/techBlog/posts/ruby_on_rails_tips/</guid><description>在class中访问元素 使用attr_accessor :foo 定义的变量foo可以不需要self.直接访问。 如
class Person attr_accessor :name def greeting name end end &amp;gt;&amp;gt; person = Person.new &amp;gt;&amp;gt; person.name = &amp;quot;maiomi&amp;quot; &amp;gt;&amp;gt; person.greeting =&amp;gt; &amp;quot;miaomi&amp;quot; 教程中解释上述现象的语句为： is created automatically by Active Record based on the name of the corresponding database column
可以不带self.取得但是如果更新不带self.的话就会建立一个函数的本地变量，不会对类的属性产生影响。 如
class Person attr_accessor :name def greeting(string) name = string end end &amp;gt;&amp;gt; person = Person.new &amp;gt;&amp;gt; person.greeting(&amp;quot;miaomi&amp;quot;) =&amp;gt; &amp;quot;miaomi&amp;quot; &amp;gt;&amp;gt; person.name =&amp;gt; nil 使用self.之后
class Person attr_accessor :name def greeting(string) self.</description></item></channel></rss>