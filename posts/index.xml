<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Day Day Up</title><link>/techBlog/posts/</link><description>Recent content in Posts on Day Day Up</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 07 Mar 2021 19:53:41 +0900</lastBuildDate><atom:link href="/techBlog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Udemy Docker learning</title><link>/techBlog/posts/docker_learning/</link><pubDate>Sun, 07 Mar 2021 19:53:41 +0900</pubDate><guid>/techBlog/posts/docker_learning/</guid><description>Section3 执行启动容器命令之后会发生什么 执行docker container run --publish 80:80 --name webhost --detach nginx之后发生的：
在本地的image cache中寻找 如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub） 下载寻找到的image最新版本 以下载好的image为基础创建一个容器container 在docker engine的private network中创建一个虚拟IP 打开主机（host）的80端口连接转发至容器的80端口 如果不用--publish选项则不会打开任何端口 使用image Dockerfile中的CMD启动容器 --detach使得container在后台运行，不接收输入与输出。 重新进入交互模式使用docker attach(需要有正在运行的bash，退出container也停止)，或者docker exec -it(退出container不停止) 参考1 参考2 Container VS. VM container不是mini VM（与VM基本没有相似之处） 只是进程（process） 被限制在其能访问的资源中 进程停止则退出 相关命令解说 docker top列出在特定的容器中执行的进程 ps aux可以发现同样的进程可以在主机系统中查询到 所以容器是一个进程
监视 docker container top 同上 docker container inspect列出启动容器时所用的设置（JSON格式）等元数据 docker container stats监视容器运行状态（CPU使用和内存等） 进入容器内部 docker container run -it以交互的方式启动容器 -t创建一个虚拟的tty -i使得会话开放来接收终端输入（keep session open to receive terminal input） 末尾可以加入想运行的命令，比如bash e.</description><content type="html"><![CDATA[<h1 id="section3">Section3</h1>
<h2 id="执行启动容器命令之后会发生什么">执行启动容器命令之后会发生什么</h2>
<p>执行<code>docker container run --publish 80:80 --name webhost --detach nginx</code>之后发生的：</p>
<ol>
<li>在本地的image cache中寻找</li>
<li>如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub）</li>
<li>下载寻找到的image最新版本</li>
<li>以下载好的image为基础创建一个容器container</li>
<li>在docker engine的private network中创建一个虚拟IP</li>
<li>打开主机（host）的80端口连接转发至容器的80端口
<ul>
<li>如果不用<code>--publish</code>选项则不会打开任何端口</li>
</ul>
</li>
<li>使用image Dockerfile中的CMD启动容器</li>
<li><code>--detach</code>使得container在后台运行，不接收输入与输出。</li>
</ol>
<ul>
<li>重新进入交互模式使用<code>docker attach</code>(需要有正在运行的bash，退出container也停止)，或者<code>docker exec -it</code>(退出container不停止)</li>
<li><a href="https://qiita.com/RyoMa_0923/items/9b5d2c4a97205692a560">参考1</a></li>
<li><a href="https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec">参考2</a></li>
</ul>
<h2 id="container-vs-vm">Container VS. VM</h2>
<h3 id="container不是mini-vm与vm基本没有相似之处">container不是mini VM（与VM基本没有相似之处）</h3>
<ul>
<li>只是进程（process）</li>
<li>被限制在其能访问的资源中</li>
<li>进程停止则退出</li>
</ul>
<h4 id="相关命令解说">相关命令解说</h4>
<p><code>docker top</code>列出在特定的容器中执行的进程
<code>ps aux</code>可以发现同样的进程可以在主机系统中查询到
所以容器是一个进程</p>
<h2 id="监视">监视</h2>
<ul>
<li><code>docker container top</code> 同上</li>
<li><code>docker container inspect</code>列出启动容器时所用的设置（JSON格式）等元数据</li>
<li><code>docker container stats</code>监视容器运行状态（CPU使用和内存等）</li>
</ul>
<h2 id="进入容器内部">进入容器内部</h2>
<ul>
<li><code>docker container run -it</code>以交互的方式启动容器
<ul>
<li><code>-t</code>创建一个虚拟的tty</li>
<li><code>-i</code>使得会话开放来接收终端输入（keep session open to receive terminal input）</li>
<li>末尾可以加入想运行的命令，比如<code>bash</code></li>
<li>e.g. <code>docker container run --name nginx -it nginx bash</code>直接进入容器的终端
<ul>
<li>退出后容器停止</li>
</ul>
</li>
</ul>
</li>
<li><code>docker container exec -it &lt;command&gt;</code>在既存的运行中的容器中以交互方式执行命令
<ul>
<li>不影响容器运行</li>
<li>需要启动容器来执行否则会报错</li>
</ul>
</li>
<li>Alpine是一个很小的linux发行版本，只有<code>sh</code>，可以通过<code>apk</code>来安装<code>bash</code></li>
</ul>
<h2 id="容器的网络">容器的网络</h2>
<h3 id="网络默认设置">网络默认设置</h3>
<ul>
<li>每个容器都连接到一个虚拟私有网络<code>bridge</code></li>
<li>每个虚拟网络都通过NAT防火墙路由至主机IP
<ul>
<li>每个容器可以通过这个路径连接到外面的网络再连接回来</li>
</ul>
</li>
<li>容器之间的通讯不需要<code>-p</code>的设置也可以实现
<ul>
<li>如一个由mysql, php/apache组成的<code>my_web_app</code>网络</li>
<li>和一个由mongo, nodejs组成的<code>my_api</code>网络</li>
<li>但是不进行设置的话不同网络之间没法互通</li>
</ul>
</li>
</ul>
<h3 id="定制化">定制化</h3>
<ul>
<li>&ldquo;Batteris included, But Removable&rdquo;
<ul>
<li>大部分情景使用默认设置即可但是可以随意定制</li>
</ul>
</li>
<li>可以将容器连接至多个或0个虚拟网络</li>
<li>可使用<code>--net=host</code>来跳过虚拟网络直接使用主机IP</li>
<li>在主机级别的端口，一个端口只能被一个容器所监听</li>
</ul>
<h3 id="代码">代码</h3>
<ul>
<li><code>-p</code>命令后的格式是<code>HOST:CONTAINER</code></li>
<li><code>docker container port &lt;container&gt;</code>显示端口映射情况</li>
<li>查看容器地址<code>docker container inspect --format &quot;{{ .NetworkSettings.IPAddress}}&quot; &lt;container&gt;</code></li>
</ul>
<h3 id="命令行管理网络">命令行管理网络</h3>
<ul>
<li><code>docker network ls</code>列出所有虚拟网络
<ul>
<li>bridge(docker0)是通过NAT防火墙连接至主机物理网络的默认网络</li>
<li>host是跳过docker的直接与主机网络接口连接的网络，牺牲了容器模式下的安全性换来了更高的网络性能</li>
<li>none:不与任何外部接口相连（eth0），只留有容器内部的localhost接口</li>
</ul>
</li>
<li><code>docker network inspect bridge</code>查看bridge网络的详情
<ul>
<li>可以看到有哪些容器连接在这个网络上</li>
<li><code>IPAM</code>可以看到网络设置，最后通过网关连接到主机物理网络</li>
</ul>
</li>
<li><code>docker network create &lt;name&gt;</code>使用bridge的驱动（默认的）创建一个虚拟网络</li>
<li>启动（run）容器时可以用<code>--network</code>来指定网络</li>
<li><code>docker network connect/disconnect &lt;network&gt; &lt;container&gt;</code>将容器连接至/断开网络连接</li>
</ul>
<h3 id="dns">DNS</h3>
<p>dcoker自带一个DNS用来解析域名（容器名）从而访问到正确的容器（使用相当于hostname的container name来实现容器之间的通讯）</p>
<ul>
<li>新建一个虚拟网络，当使用<code>--network</code>来将不通的容器连接至虚拟网络时，或自动以容器名为key来建立DNS服务，这样同一个虚拟网络之间的容器就可以互相连通</li>
<li>默认的<code>bridge</code>虚拟网络没有这种服务，每次添加新的容器如果需要与其他容器连接则需要手动使用<code>--link &lt;list of container&gt;</code>来设置</li>
</ul>
<h1 id="section4-image">Section4 Image</h1>
<h2 id="什么是image-包括">什么是Image （包括）</h2>
<ul>
<li>应用的二进制和依赖文件数据</li>
<li>image data的元数据和如何运行image的设定参数</li>
</ul>
<h2 id="image-layers">Image layers</h2>
<ul>
<li>
<p><code>docker image history</code> 显示Image layer的历史</p>
<ul>
<li>除了第一个履历有Image ID之外其他都为<!-- raw HTML omitted -->, 因为其他的layer只是构成Image的一部分并不是Image本身，所以不配拥有ID。</li>
</ul>
</li>
<li>
<p>每个Image都从成为scratch的空layer开始，在这之后发生在Image的文件系统中的改变都是一个layer
<img src="https://github.com/ACGNM/pics/raw/master/docker/image_layers.png" alt="例图">
<img src="https://github.com/ACGNM/pics/raw/master/docker/custom_image.png" alt="例图">
<img src="https://github.com/ACGNM/pics/raw/master/docker/copy_on_write.png" alt="pic"></p>
</li>
<li>
<p><code>docker image inspect</code> 取得Image的metadata (Image如何运行，Image的JSON格式的详细信息)</p>
</li>
</ul>
<h2 id="image-tag">image tag</h2>
<ul>
<li><code>dokcer image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code>
<ul>
<li><code>docker image tag --help</code>来查看用法</li>
<li>根据SOURCE_IMAGE(with tag <code>TAG</code>)来创建一个TARGET_IMAGE（默认tag为latest）</li>
<li>总是创建一个新记录（对于执行 <code>docker image ls</code>的结果）</li>
</ul>
</li>
<li>只是一个用来区分的名称。如nginx的latest和mainline是拥有同一个image ID的image。都pull下来时，pull第二个会显示已经存在。但是在<code>docker image ls</code>中分开显示（同时可以发现两者image ID相同）</li>
<li>默认的tag是<code>latest</code>。但并不代表就是最新的</li>
<li><code>docker image push</code>可以向Docker Hub上传变更过layer的image
<ul>
<li>这之前需要先登陆。使用<code>docker login</code></li>
<li>在<code>./docker/config.json</code>中存储docker Hub的认证信息
如果想上传一个私人（private）的image，则先需要建立一个私人仓库然后再上传</li>
</ul>
</li>
</ul>
<h2 id="dockerfile基础">Dockerfile基础</h2>
<h3 id="参考dockerfile-sample-1注释">参考dockerfile-sample-1注释</h3>
<ul>
<li><a href="https://github.com/BretFisher/udemy-docker-mastery/blob/main/dockerfile-sample-1/Dockerfile">dockerfile-sample-1</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#usage">官方相关文档</a></li>
</ul>
<h3 id="建立image-building-image">建立Image (building Image)</h3>
<ul>
<li>首先改变当前目录至存在<code>Dockerfile</code>的目录中
<ul>
<li>如果想使用非默认名称 (Dockerfile) 的dockerfile, 使用<code>-f</code>选项 (<code>docker image build -f &lt;dockerfile_name&gt;</code>)</li>
</ul>
</li>
<li><code>docker image build -t IMAGE_NAME[:TAG] &lt;path&gt;</code>
<ul>
<li>如果只是本地使用，则不需要在前面加上Docker Hub的account name</li>
</ul>
</li>
<li>接下来的输出对应Dockerfile的每一个stanza的命令
<ul>
<li>每一步会对应一个存在build Cache中的Hash用来标记每一步</li>
<li>如果下一次build时Dockerfile的对应那一行没有变化则不会再执行一边相同的stanza</li>
<li>如果有所该表则重新执行有变化的stanza及其之后的所有stanza</li>
<li>Docker的build快速是因为docker将每一步都放入缓存中</li>
</ul>
</li>
<li>扩展官方image
<ul>
<li>使用  <a href="https://github.com/BretFisher/udemy-docker-mastery/blob/main/dockerfile-sample-2">dockerfile-sample-2</a></li>
<li>可以直接<code>FROM</code>官方的Image来加入自定义设置</li>
<li>可以继承来<code>FROM</code>里的所有stanza，所以不需要加入<code>CMD</code>等必要的stanza</li>
<li><code>WORKDIR</code>相当于执行了<code>cd</code>命令</li>
<li><code>docker conainer run</code>的<code>-rm</code>flag用来告诉docker，当container退出后clean up container和其file system</li>
</ul>
</li>
</ul>
]]></content></item></channel></rss>