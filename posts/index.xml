<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Day Day Up</title><link>/techBlog/posts/</link><description>Recent content in Posts on Day Day Up</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 21 Mar 2021 01:07:15 +0900</lastBuildDate><atom:link href="/techBlog/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>React</title><link>/techBlog/posts/react/</link><pubDate>Sun, 21 Mar 2021 01:07:15 +0900</pubDate><guid>/techBlog/posts/react/</guid><description>React terms JSX: Javascript Syntax Extention (allow us to write dynamic html) Virtual DOM (Document Object Model) ternary operator 三元运算符 Component 两种形式：函数形式和类形式 使用props在组件之间传递值（类似于JS中的函数参数） State determines how a component reders and behaves 相当于属性，在组件中存储数据 &amp;ldquo;app&amp;rdquo; state and &amp;ldquo;global&amp;rdquo; state refers to state that is avalable to the entire UI 如果最后出现一大堆全局state, 可以使用context api或者使用第三方的state管理器redux React Hooks 是一系列函数让函数形式的组件可以像类组件一样使用state和其lifecycle create react app Tips react-dom: responsilble for rendering react application out to the domcument object model to the browser react-javascript: comes with development server and build tools index.</description><content type="html"><![CDATA[<h1 id="react">React</h1>
<h2 id="terms">terms</h2>
<ul>
<li>JSX: Javascript Syntax Extention (allow us to write dynamic html)</li>
<li>Virtual DOM (Document Object Model)</li>
<li>ternary operator 三元运算符</li>
</ul>
<h2 id="component">Component</h2>
<ul>
<li>两种形式：函数形式和类形式</li>
<li>使用props在组件之间传递值（类似于JS中的函数参数）</li>
</ul>
<h2 id="state">State</h2>
<ul>
<li>determines how a component reders and behaves</li>
<li>相当于属性，在组件中存储数据</li>
<li>&ldquo;app&rdquo; state and &ldquo;global&rdquo; state refers to state that is avalable to the entire UI</li>
<li>如果最后出现一大堆全局state, 可以使用context api或者使用第三方的state管理器<code>redux</code></li>
</ul>
<h2 id="react-hooks">React Hooks</h2>
<ul>
<li>是一系列函数让函数形式的组件可以像类组件一样使用state和其lifecycle</li>
</ul>
<h2 id="create-react-app">create react app</h2>
<h3 id="tips">Tips</h3>
<ul>
<li><code>react-dom</code>: responsilble for rendering react application out to the domcument object model to the browser</li>
<li><code>react-javascript</code>: comes with development server and build tools</li>
<li><code>index.js</code>: entry point of react</li>
<li>组件函数的返回值必须是一个有父母元素的JSX。如果不想让返回的要素再包裹一层div（作为empty fragment返回），则使用<code>&lt;&gt;...&lt;/&gt;</code>包裹即可</li>
<li>在嵌入的JSX代码中设置style需要用双花括号 <code>return &lt;div style={{ color: 'red' }}&gt;...&lt;/div&gt;</code></li>
<li>使用js的map函数生成的list的每个要素都要有一个唯一的key。不然控制台会报警</li>
</ul>
]]></content></item><item><title>Networking_coursera</title><link>/techBlog/posts/networking_coursera/</link><pubDate>Sun, 14 Mar 2021 23:21:58 +0900</pubDate><guid>/techBlog/posts/networking_coursera/</guid><description>The Bits and Bytes of Computer Networking First Week protocol a define set of standards that computers must follwo in order to communicate properly.
TCP/IP Five Layer Network Model Overview Physical layer Represents the physical devices that interconnect computers
Data link layer Responsible for defining a common way of interpreting(解释, 翻译) these signals so network devices can communicate
在数据连接层有许多协议，最常见的是以太网（Ethernet） the Ethernet standards also define a protocol responsible for getting data to nodes on the same network or link.</description><content type="html"><![CDATA[<h1 id="the-bits-and-bytes-of-computer-networking">The Bits and Bytes of Computer Networking</h1>
<h2 id="first-week">First Week</h2>
<h3 id="protocol">protocol</h3>
<p>a define set of standards that computers must follwo in order to communicate properly.</p>
<h3 id="tcpip-five-layer-network-model">TCP/IP Five Layer Network Model</h3>
<h4 id="overview">Overview</h4>
<p><img src="https://github.com/ACGNM/pics/raw/master/networking/TCP:IP%20five%20layers.png" alt="five layers"></p>
<h4 id="physical-layer">Physical layer</h4>
<p>Represents the physical devices that interconnect computers</p>
<h4 id="data-link-layer">Data link layer</h4>
<p>Responsible for defining a common way of interpreting(解释, 翻译) these signals so network devices can communicate</p>
<ul>
<li>在数据连接层有许多协议，最常见的是以太网（Ethernet）
<ul>
<li>the Ethernet standards also define a protocol responsible for getting data to nodes on the same network or link.</li>
</ul>
</li>
<li>其他的还有越来越多的比如Wifi。</li>
</ul>
<h4 id="network-layer">Network layer</h4>
<ul>
<li>Allows different networks to communicate with each other through devices known as routers. (使得由路由器相连的不同网络之间可以互相通讯)</li>
<li>Internetwork
<ul>
<li>A collection of networks connected together routers</li>
<li>the most famous of these being Internet</li>
</ul>
</li>
</ul>
<p>Data link layer 用来让数据跨越单个链接，Network layer 用来让数据在网络的集合中传输（在节点之间传输）</p>
<h4 id="transport-layer">Transport layer</h4>
<ul>
<li>Sorts out which client and server programs are supposed to get that data （分发数据给对应的客户/服务程序）</li>
<li>TCP: Transmission Control Protocol</li>
<li>UDP: User Datagram Protocol</li>
</ul>
<h4 id="applicaiton-layer">Applicaiton layer</h4>
<p>用来让用户可以发送邮件和浏览网页等等行为的的协议</p>
<h4 id="类比物流">类比物流</h4>
<p><img src="https://github.com/ACGNM/pics/raw/master/networking/layers.png" alt="layers"></p>
<h3 id="basic-of-networking-devices">Basic of Networking Devices</h3>
<h4 id="cables">Cables</h4>
<h4 id="hubs-and-switches">Hubs and Switches</h4>
<ul>
<li>Hub是物理层设备，交换机是数据链路层设备</li>
<li>Hub在接收到信号时会发送至连接到Hub的所有其他设备。而交换机则会根据以太网协议只发送给目标节点。所以当所有节点同时发送信息时，Hub的信号会互相干扰所以会有很长的等待时间，而交换机避免了这样的事。</li>
<li>The primary devices used to connect computers on a single network, usually referred to as a <strong>LAN</strong>, or <strong>Local Area Network</strong>.</li>
</ul>
<h4 id="routers">Routers</h4>
<ul>
<li>
<p>A router is a device that knows how to forward data between independent networks. (网络层设备)</p>
</li>
<li>
<p><strong>BGP (Border Gateway Protocol)</strong></p>
<ul>
<li>Routers share data with each other via a protocol known as BGP, that let&rsquo;s them learn about the most optimal paths to forward traffic.</li>
</ul>
</li>
</ul>
<h3 id="the-physical-layer">The Physical Layer</h3>
<h4 id="modulation">Modulation</h4>
<p>A way of varing the voltage of this charge moving across the cable</p>
<ul>
<li>Used in twisted pair (双绞线) known as <strong>Line coding</strong></li>
<li>利用双绞线可以实现全双工（full-duplex）和半双工（half-duplex）
<ul>
<li>全双工两边可以同时进行通信，半双工在一段时间内只有一方可以传递数据</li>
<li>一到两对双绞线给双向通讯中的某个单项通讯保证留有信道</li>
</ul>
</li>
</ul>
<p><img src="https://github.com/ACGNM/pics/raw/master/networking/cables.png" alt="cables"></p>
<h4 id="network-port">Network Port</h4>
<ul>
<li>最常见的接口是RJ450接口（Register Jack 45）
<ul>
<li>左右两个LED。左边的闪说明两边都连接着启动中的设备。右边闪说明在进行数据传输。
<img src="https://github.com/ACGNM/pics/raw/master/networking/RJ45.png" alt="RJ45"></li>
</ul>
</li>
</ul>
<h4 id="patch-panel">Patch Panel</h4>
<p>有许多端口，仅仅起集线作用，输出端一般连接到交换机。
<img src="https://github.com/ACGNM/pics/raw/master/networking/Patch_panel.png" alt="Patch Panel"></p>
<h3 id="the-data-link-layer">The Data Link Layer</h3>
<p>一开始以太网一次只能由一台节点的发送信息。因为所每次发送信息都会发送到网络中除发送方之外的的所有节点。则如果两台电脑同时发送信息则会造成碰撞。</p>
<ul>
<li>Ethernet as protocol solved this problem by using a technique known as <strong>carrier sense multiple access with collision detection</strong>.</li>
<li><strong>CSMA/CD</strong>  used to determine when the commucations channels are clear, and when a device is free to transmit data.</li>
<li>所以在collision domain中任意在网络中的节点都会接受到所有网络其他节点发送的信息</li>
</ul>
<h4 id="所以需要一种方式来识别传输朝向哪个节点"><strong>所以需要一种方式#来识别传输朝向哪个节点</strong></h4>
<p>这就是<strong>Media Acess Control Address (MAC地址)</strong></p>
<ul>
<li>A golablly unique identifier attached to an individual network interface</li>
<li>48-bit number normally represented by six groupings of two hexadecimal numbers <strong>由48位的六组两位十六进制数表示</strong></li>
<li><strong>Octet: any number that can be represented by 8 bits</strong></li>
<li>Two hexadecimal digits can represent the same numbers that 8 bits can <strong>两位的十六进制数可以表示8位所代表的数字 (FF=2^8-1)</strong></li>
</ul>
<p>MAC address的形式</p>
<ul>
<li>前三个octet是Organization Unique Identifier(OUI)</li>
<li>后三位Vendor Assigned</li>
<li>相当于分成两个24位的部分</li>
</ul>
]]></content></item><item><title>Jvm_learning</title><link>/techBlog/posts/jvm_learning/</link><pubDate>Sun, 07 Mar 2021 21:24:28 +0900</pubDate><guid>/techBlog/posts/jvm_learning/</guid><description>JVM与JAVA体系结构 主要研究官方提供的HotSpot虚拟机 不管什么语言，只要提供编译器编译出遵循JVM规范的字节码文件，就可以在Java虚拟机运行。 在Java虚拟机中执行的指令成为Java字节码指令 虚拟机分为系统虚拟机和软件虚拟机 系统虚拟机模拟硬件环境，软件虚拟机运行在操作系统之上，不与硬件进行直接交互。
JVM的位置 java代码(.java文件)编译成字节码文件(.class文件)给JVM执行 JVM整体结构 执行引擎用来解释运行。其中只用解释器的话对于反复被执行的热点代码的优化不够，所以引入JIT编译器(Just-In-Time Compiler)来提前将字节码文件编译成二进制机器命令。同时加入了垃圾回收机制。 将各种语言的代码编译为字节码文件的编译器是前端编译器，执行引擎的JIT编译器是后端编译器。 字节码指令不等同于机器指令，将字节码指令翻译为机器指令的部分就是执行引擎。
Java代码执行流程 一般都采用的是解释执行和即时编译并存的执行引擎。(即图中Java虚拟机最左端部分) JIT编译器将反复执行的热点代码编译为机器指令后还会将其缓存起来。
由于跨平台的设计，Java的指令都是根据栈来实现的 指令集可以分为基于栈的指令集架构和基于寄存器的指令集架构。 零地址指令 没有操作的地址，只有操作数。 一地址指令 有一个地址，然后是操作数 二地址三地址以此类推
栈：跨平台性，指令集小，指令数量多，执行性能比寄存器差
JVM发展(各种虚拟机) Sun Classic VM (HotSpot里内置了)： 只提供解释器 Exact VM： 可以知道某个内存中的数据是什么类型，编译器(负责执行性能)解释器(负责响应时间)混合工作 HotSpot VM：独有方法区(JRockit，J9都没有) JRockit：专注于服务端应用，不包含解释器。世界上最快的JVM。MissionControl服务套件。 IBM的J9：三大商用JVM之一 Dalvik VM：应用于安卓，没有遵守Java虚拟机规范，基于寄存器架构。 Graal VM：跨语言全栈虚拟机。最有希望取代HotSpot VM。 类加载子系统</description><content type="html"><![CDATA[<h2 id="jvm与java体系结构">JVM与JAVA体系结构</h2>
<h3 id="主要研究官方提供的hotspot虚拟机">主要研究官方提供的HotSpot虚拟机</h3>
<p><img src="https://i.ibb.co/n3pqprG/2020-10-11-15-05-59.png" alt="HotSpot"></p>
<h3 id="不管什么语言只要提供编译器编译出遵循jvm规范的字节码文件就可以在java虚拟机运行">不管什么语言，只要提供编译器编译出遵循JVM规范的字节码文件，就可以在Java虚拟机运行。</h3>
<p><img src="https://i.ibb.co/bdvRS13/2020-10-11-15-06-28.png" alt="结构"></p>
<h3 id="在java虚拟机中执行的指令成为java字节码指令">在Java虚拟机中执行的指令成为Java字节码指令</h3>
<h3 id="虚拟机分为系统虚拟机和软件虚拟机">虚拟机分为系统虚拟机和软件虚拟机</h3>
<p>系统虚拟机模拟硬件环境，软件虚拟机运行在操作系统之上，不与硬件进行直接交互。</p>
<h3 id="jvm的位置">JVM的位置</h3>
<p><img src="https://i.ibb.co/K5vgxq8/2020-10-11-21-50-24.png" alt="JVM的位置"></p>
<p>java代码(.java文件)编译成字节码文件(.class文件)给JVM执行
<img src="https://i.ibb.co/MpQbPdq/2020-10-11-21-57-30.png" alt="JVM, JRE, JDK"></p>
<h3 id="jvm整体结构">JVM整体结构</h3>
<p><img src="https://i.ibb.co/hydtksj/2020-10-12-00-01-34.png" alt="JVM整体结构">
执行引擎用来解释运行。其中只用解释器的话对于反复被执行的热点代码的优化不够，所以引入JIT编译器(Just-In-Time Compiler)来提前将字节码文件编译成二进制机器命令。同时加入了垃圾回收机制。
将各种语言的代码编译为字节码文件的编译器是前端编译器，执行引擎的JIT编译器是后端编译器。
字节码指令不等同于机器指令，将字节码指令翻译为机器指令的部分就是执行引擎。</p>
<h3 id="java代码执行流程">Java代码执行流程</h3>
<p><img src="https://i.ibb.co/B2HCzgK/2020-10-12-00-58-55.png" alt="Java代码执行流程">
一般都采用的是解释执行和即时编译并存的执行引擎。(即图中Java虚拟机最左端部分)
JIT编译器将反复执行的热点代码编译为机器指令后还会将其缓存起来。</p>
<h3 id="由于跨平台的设计java的指令都是根据栈来实现的">由于跨平台的设计，Java的指令都是根据栈来实现的</h3>
<p><img src="https://i.ibb.co/m47vkZz/2020-10-12-01-42-48.png" alt="指令集">
指令集可以分为基于栈的指令集架构和基于寄存器的指令集架构。
零地址指令 没有操作的地址，只有操作数。
一地址指令 有一个地址，然后是操作数
二地址三地址以此类推</p>
<p>栈：跨平台性，指令集小，指令数量多，执行性能比寄存器差</p>
<h3 id="jvm发展各种虚拟机">JVM发展(各种虚拟机)</h3>
<ul>
<li>Sun Classic VM (HotSpot里内置了)： 只提供解释器</li>
<li>Exact VM： 可以知道某个内存中的数据是什么类型，编译器(负责执行性能)解释器(负责响应时间)混合工作</li>
<li>HotSpot VM：独有方法区(JRockit，J9都没有)</li>
<li>JRockit：专注于服务端应用，不包含解释器。世界上最快的JVM。MissionControl服务套件。</li>
<li>IBM的J9：三大商用JVM之一</li>
<li>Dalvik VM：应用于安卓，没有遵守Java虚拟机规范，基于寄存器架构。</li>
<li>Graal VM：跨语言全栈虚拟机。最有希望取代HotSpot VM。</li>
</ul>
<h2 id="类加载子系统">类加载子系统</h2>
]]></content></item><item><title>Udemy_linux</title><link>/techBlog/posts/udemy_linux/</link><pubDate>Sun, 07 Mar 2021 21:23:26 +0900</pubDate><guid>/techBlog/posts/udemy_linux/</guid><description>Day 1 查找Linux发行版的网站 DistroWatch.com
Day 2 /etc 系统设置文件夹
/var 主要是日志文件存储地
/usr/local 非系统自带软件安装地（并非所有） /opt 可选，第三方软件安装地
具体内容有可能是软件目录下有自己的目录结构，也有可能共享目录（说的是设置，日志等）：如在/etc下存储自己的设置，在/var下存储自己的日志 &amp;lt;- 不在自己的安装目录下
例子1
/etc/opt/myapp /opt/myapp/bin /opt/myapp/lib /var/opt/myapp 例子2
/usr/local/bin/myapp /usr/local/lib/libmyapp.so /usr/local/etc/myapp.conf Tilde(波浪号，チルダ) ~jason = /home/jason ~gongzhihao = /home/gongzhihao ~root = /root ~ftp = /srv/ftp
man 相关
使用man查询用法说明后，回车下一行，空格下一页，g回到顶端，G到底部（shift+g），推出按q man -k 搜索内容 在man页面中进行搜索 环境变量</description><content type="html"><![CDATA[<h2 id="day-1">Day 1</h2>
<p>查找Linux发行版的网站 <a href="https://distrowatch.com/?language=EN">DistroWatch.com</a></p>
<h2 id="day-2">Day 2</h2>
<ul>
<li>
<p>/etc 系统设置文件夹</p>
</li>
<li>
<p>/var 主要是日志文件存储地</p>
</li>
<li>
<p>/usr/local 非系统自带软件安装地（并非所有）
/opt 可选，第三方软件安装地</p>
<ul>
<li>
<p>具体内容有可能是软件目录下有自己的目录结构，也有可能共享目录（说的是设置，日志等）：如在/etc下存储自己的设置，在/var下存储自己的日志 &lt;- 不在自己的安装目录下</p>
</li>
<li>
<p>例子1</p>
<pre><code>/etc/opt/myapp
/opt/myapp/bin
/opt/myapp/lib
/var/opt/myapp
</code></pre></li>
<li>
<p>例子2</p>
<pre><code>/usr/local/bin/myapp
/usr/local/lib/libmyapp.so
/usr/local/etc/myapp.conf
</code></pre><pre><code>
</code></pre></li>
</ul>
</li>
<li>
<p>Tilde(波浪号，チルダ)
<code>~jason = /home/jason ~gongzhihao = /home/gongzhihao ~root = /root ~ftp = /srv/ftp</code></p>
</li>
<li>
<p>man 相关</p>
<ul>
<li>使用man查询用法说明后，回车下一行，空格下一页，g回到顶端，G到底部（shift+g），推出按q</li>
<li><code>man -k 搜索内容</code> 在man页面中进行搜索</li>
</ul>
</li>
<li>
<p>环境变量</p>
<ul>
<li>PATH：里面的值是执行命令时的搜索路径（执行后在里面搜索对象，目录之间用冒号隔开）</li>
</ul>
</li>
<li>
<p><code>cd -</code> 回到刚才的目录</p>
</li>
<li>
<p><code>pwd</code> present working directory</p>
</li>
<li>
<p><code>echo $OLDPWD</code> 刚才的工作目录（= <code>cd -</code>）</p>
</li>
<li>
<p><strong>创建和删除目录</strong></p>
<ul>
<li><code>mkdir [-p] 目录名</code> -p 是用来创建父目录（parent）或者说可以直接创建深层目录如：mkdir -p 1/2/3</li>
<li><code>rmdir [-p] 目录名</code> -p 作用同上（但是只能删除空目录）</li>
<li><code>rm -rf 目录名</code> 递归删除目录下所有内容（recursively delete）</li>
</ul>
</li>
<li>
<p>显示文件或者目录信息</p>
<ul>
<li><code>ls -F</code>  显示文件类型
<ul>
<li><code>/</code> 目录。<code>@</code> 链接。<code>*</code> 可执行文件</li>
</ul>
</li>
<li><code>ls -t</code> 按时间排序。 <code>ls -r</code> 逆向排序。 <code>ls -latr</code> 将所有文件详的细信息按照时间逆序排列（最新的在最下面）。</li>
<li><code>ls -R</code> 递归地显示当前文件夹下的所有内容。<code>ls --color</code> 将结果上色。<code>ls -d</code> 只显示目录。</li>
<li><code>tree</code> 输出树形结构。<code>tree -d</code>只显示目录不显示文件。<code>ls -c</code>给结果上色。</li>
<li>如果目标文件或者目录有空格，使用双引号或者单引号括住文件名来执行命令。 如 <code>ls &quot;my notes.txt&quot;</code> 。</li>
</ul>
</li>
</ul>
<h2 id="day-3">Day 3</h2>
<ul>
<li>
<p>权限定义</p>
<ul>
<li>
<p>ugoa 代表 user, group, other, all</p>
</li>
<li>
<p>修改权限: chmod ugoa(中的一种或几种) +/-/= 权限（rwx）文件名</p>
<ul>
<li>e.g. <code>chmod u+rw,g+w sales.data</code></li>
</ul>
</li>
<li>
<p>用数字代表的权限:</p>
<table>
<thead>
<tr>
<th>r</th>
<th>w</th>
<th>x</th>
</tr>
</thead>
<tbody>
<tr>
<td>4</td>
<td>2</td>
<td>1</td>
</tr>
</tbody>
</table>
<ul>
<li>指定的权限是数字的加和
<ul>
<li><code>chmod 644 sales.data</code> (-rw-r&ndash;r&ndash;)</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>创建一个文件默认被指定到当前用户的主群组（primary group）</p>
<ul>
<li>如果想改变所属的群组，使用<code>chgrp</code></li>
</ul>
</li>
<li>
<p>文件的权限会受到所在文件夹权限的影响</p>
<ul>
<li>即使文件本身的权限可读（或者其他），如果所在文件夹甚至其所在文件夹的父文件夹(及其父文件夹直至root)的权限上不允许，则无法执行想要的动作</li>
</ul>
</li>
<li>
<p>创建文件时的默认权限（File Creation Mask）是指创建文件时赋予的权限</p>
<ul>
<li>如果创建时没有指定<code>mask</code>
<ul>
<li>目录默认给予777</li>
<li>文件默认给予666</li>
</ul>
</li>
<li><code>umask</code>命令用来查看当前文件夹赋予的默认权限状况
<ul>
<li>与<code>chmod</code>相反，显示的结果是创建时减去的值
<ul>
<li>如默认创建文件时权限为<code>666</code>，<code>umask</code>结果为<code>0022</code>时创建文件权限会被自动设置为<code>644</code></li>
</ul>
</li>
<li>以四位表示，转换为三位去掉最前面的零即可（如<code>0022=022</code>）</li>
<li><code>umask 007</code>将umask设置为<code>00007</code>(即创建文件或目录时Other权限为0)</li>
</ul>
</li>
</ul>
</li>
<li>
<p>浏览文件内容</p>
<ul>
<li><code>cat</code></li>
<li><code>more</code></li>
<li><code>less</code></li>
<li><code>head</code></li>
<li><code>tail</code>
<ul>
<li><code>tail -f</code>可以持续追踪文件内容</li>
<li><code>tail -n</code>指定显示最后多少行（<code>head</code>同样用法）</li>
<li>默认显示10行</li>
</ul>
</li>
</ul>
</li>
<li>
<p>编辑文件</p>
<ul>
<li><code>nano</code></li>
<li><code>vi</code>
<ul>
<li><code>vim</code>是vi improvement</li>
<li>分为三个模式
<ul>
<li>Command Mode
<ul>
<li><code>k, j</code>:上一行, 下一行</li>
<li><code>h, l</code>:左一字符，右一字符</li>
<li><code>w, b</code>:左一词，右一词</li>
<li><code>^, $</code>:到本行的开始，结束</li>
</ul>
</li>
<li>Insert Mode
<ul>
<li><code>i</code> 在光标位置插入</li>
<li><code>I</code> 在行的开头处插入</li>
<li><code>a</code> 在光标后插入</li>
<li><code>A</code> 在行的结尾处插入</li>
</ul>
</li>
<li>Line Mode
<ul>
<li><code>:w</code> 写入文件</li>
<li><code>:w!</code> 强行写入</li>
<li><code>:q</code> 退出</li>
<li><code>:q!</code> 退出但不保存</li>
<li><code>:wq!</code> 保存并退出</li>
<li><code>:x</code> 与:wq相同</li>
<li><code>:n</code> 将光标放在第n行</li>
<li><code>$</code> 将光标放在最后一行</li>
<li><code>set nu/noun</code> 显示/关闭行数显示</li>
</ul>
</li>
</ul>
</li>
<li>重复命令
<ul>
<li><code>5k</code> 光标向上移动五行</li>
<li><code>80i&lt;Text&gt;&lt;Esc&gt;</code> 插入<!-- raw HTML omitted -->八十次</li>
</ul>
</li>
<li>删除命令
<ul>
<li><code>x</code> 删除一个字符</li>
<li><code>dw</code> 删除一个单词</li>
<li><code>dd</code> 删除一行</li>
<li><code>D</code> 从当前位置开始删除</li>
<li><code>Dd</code> 删除从当前位置到结尾的内容</li>
</ul>
</li>
<li>替换/改变命令
<ul>
<li><code>r</code> 改变当前字符</li>
<li><code>cw</code> 改变一个词</li>
<li><code>cc</code> 改变当前行</li>
<li><code>c$</code> 改变当前位置到结尾的内容</li>
<li><code>C</code> 与<code>c$</code>相同</li>
<li><code>~</code> 改变当前字符大小写</li>
</ul>
</li>
<li>复制与粘贴
<ul>
<li><code>yy</code> 复制当前的行</li>
<li><code>y&lt;position&gt;</code> 复制指定位置的字符
<ul>
<li><code>yw</code>, <code>y3w</code> 复制一个词，复制三个词</li>
</ul>
</li>
<li><code>p</code> 粘贴最近删除或复制的内容</li>
</ul>
</li>
<li><code>u</code>, <code>Ctrl-R</code> Undo和Redo</li>
<li><code>/&lt;pattern&gt;</code>, <code>?&lt;pattern&gt;</code> 向后，向前搜索</li>
</ul>
</li>
<li>Emacs</li>
</ul>
</li>
<li>
<p>只有特定group的人有权限怎么做？</p>
</li>
</ul>
]]></content></item><item><title>Ruby_on_rails_tips</title><link>/techBlog/posts/ruby_on_rails_tips/</link><pubDate>Sun, 07 Mar 2021 21:22:31 +0900</pubDate><guid>/techBlog/posts/ruby_on_rails_tips/</guid><description>在class中访问元素 使用attr_accessor :foo 定义的变量foo可以不需要self.直接访问。 如
class Person attr_accessor :name def greeting name end end &amp;gt;&amp;gt; person = Person.new &amp;gt;&amp;gt; person.name = &amp;quot;maiomi&amp;quot; &amp;gt;&amp;gt; person.greeting =&amp;gt; &amp;quot;miaomi&amp;quot; 教程中解释上述现象的语句为： is created automatically by Active Record based on the name of the corresponding database column
可以不带self.取得但是如果更新不带self.的话就会建立一个函数的本地变量，不会对类的属性产生影响。 如
class Person attr_accessor :name def greeting(string) name = string end end &amp;gt;&amp;gt; person = Person.new &amp;gt;&amp;gt; person.greeting(&amp;quot;miaomi&amp;quot;) =&amp;gt; &amp;quot;miaomi&amp;quot; &amp;gt;&amp;gt; person.name =&amp;gt; nil 使用self.之后
class Person attr_accessor :name def greeting(string) self.</description><content type="html"><![CDATA[<h3 id="在class中访问元素">在class中访问元素</h3>
<p>使用<code>attr_accessor :foo</code> 定义的变量<code>foo</code>可以不需要<code>self.</code>直接访问。
如</p>
<pre><code>class Person
  attr_accessor :name
  
  def greeting
    name
  end
end

&gt;&gt; person = Person.new
&gt;&gt; person.name = &quot;maiomi&quot;
&gt;&gt; person.greeting
=&gt; &quot;miaomi&quot;
</code></pre><p>教程中解释上述现象的语句为：
<code>is created automatically by Active Record based on the name of the corresponding database column</code></p>
<p>可以不带<code>self.</code>取得但是如果更新不带<code>self.</code>的话就会建立一个函数的本地变量，不会对类的属性产生影响。
如</p>
<pre><code>class Person
  attr_accessor :name

  def greeting(string)
    name = string
  end
end

&gt;&gt; person = Person.new
&gt;&gt; person.greeting(&quot;miaomi&quot;)
=&gt; &quot;miaomi&quot;
&gt;&gt; person.name
=&gt; nil
</code></pre><p>使用<code>self.</code>之后</p>
<pre><code>class Person
  attr_accessor :name

  def greeting(string)
    self.name = string
  end
end

&gt;&gt; person = Person.new
&gt;&gt; person.greeting(&quot;miaomi&quot;)
=&gt; &quot;miaomi&quot;
&gt;&gt; person.name
=&gt; &quot;miaomi&quot;
</code></pre><h3 id="bcryptpassword的用法">BCrypt::Password的用法</h3>
<p>判断数据库中的加密过的密码是否与提交的密码匹配，使用处理如下：</p>
<pre><code>BCrypt::Password.new(remember_digest).is_password?(remember_token)

or 

BCrypt::Password.new(remember_digest) == (remember_token)
</code></pre><p>这里的<code>==</code>被重写过，将提交的password加密后与数据库中的被加密过的密码比较
参考：
<a href="https://github.com/codahale/bcrypt-ruby/blob/9f3fb05ba7b3732a87e0305ec635d7773bf1fafb/lib/bcrypt/password.rb#L66">https://github.com/codahale/bcrypt-ruby/blob/9f3fb05ba7b3732a87e0305ec635d7773bf1fafb/lib/bcrypt/password.rb#L66</a>
使用例：
<a href="https://www.rubydoc.info/github/codahale/bcrypt-ruby/BCrypt/Password">https://www.rubydoc.info/github/codahale/bcrypt-ruby/BCrypt/Password</a></p>
<h3 id="在不同网页标签中登录同一用户其中一个登出后另一个再登出出现actioncontrollerinvalidauthenticitytoken错误">在不同网页标签中登录同一用户，其中一个登出后另一个再登出出现<code>ActionController::InvalidAuthenticityToken</code>错误</h3>
<p>修复方法参考
<a href="https://qiita.com/_ayk_study/items/88269643c675fd4ca975">https://qiita.com/_ayk_study/items/88269643c675fd4ca975</a></p>
<h3 id="其他零碎的知识">其他零碎的知识</h3>
<ol>
<li></li>
</ol>
<pre><code>User.find_by(id: cookies.encrypted[:user_id])
</code></pre><p>where cookies.encrypted[:user_id] automatically decrypts the user id cookie.</p>
<ol start="2">
<li></li>
</ol>
<p>不带<code>@</code>的变量是普通（非实例）变量 -&gt; <code>normal (non-instance) variable</code>
在测试中不能用<code>assigns(:foo)</code>来获取</p>
<ol start="3">
<li></li>
</ol>
<p><code>session</code> method are automatically encrypted
参考
<a href="https://stackoverflow.com/questions/39601527/how-session-works-in-rails">https://stackoverflow.com/questions/39601527/how-session-works-in-rails</a></p>
<ol start="4">
<li></li>
</ol>
<p>so how does Rails know to use a POST request for new users and a PATCH for editing users? The answer is that it is possible to tell whether a user is new or already exists in the database via Active Record’s new_record? boolean method:</p>
<pre><code>$ rails console
&gt;&gt; User.new.new_record?
=&gt; true
&gt;&gt; User.first.new_record?
=&gt; false
</code></pre><p>When constructing a form using form_with(@user), Rails uses POST if @user.new_record? is true and PATCH if it is false.</p>
<ol start="5">
<li></li>
</ol>
<p>使用<code>target=&quot;_blank&quot;</code>进行跳转时的安全问题。
<a href="https://imququ.com/post/the-security-of-window-opener-location.html">https://imququ.com/post/the-security-of-window-opener-location.html</a></p>
<ol start="6">
<li></li>
</ol>
<p>fixture中的用户保存时不会被model中的<code>before_save</code>限制，就导致如果大小写不注意的话测试中的登陆会失败。</p>
<ol start="7">
<li></li>
</ol>
<p><code>belongs_to</code>的<code>foreign_key:</code>和<code>primary_key:</code>选项
<code>foreign_key:</code>指定自己存储外键的行（column）的名称
<code>primary_key:</code>指定自己存储外键的行中的值来自从属model的哪一行（column）</p>
<p><code>has_many</code>的<code>foreign_key:</code>和<code>primary_key:</code>选项
<code>foreign_key:</code>指定子类存储外键的行（column）的名称
<code>primary_key:</code>指定子类存储外键的行中的值来自自己的哪一行（column）</p>
<p>问题：
polymorphic_path 生成的路径会有单数的时候
如/article_latest/1
答：参考下面（用单数重写的话就会保持单数）
<a href="https://stackoverflow.com/questions/23931120/how-does-form-for-generate-paths-in-rails">https://stackoverflow.com/questions/23931120/how-does-form-for-generate-paths-in-rails</a></p>
]]></content></item><item><title>Sprint_guide</title><link>/techBlog/posts/sprint_guide/</link><pubDate>Sun, 07 Mar 2021 21:03:15 +0900</pubDate><guid>/techBlog/posts/sprint_guide/</guid><description>学习spring的基本知识找不到好的课程所以跟着官方Guides学习
1.建立一个resful服务
为了学习基础知识，不使用Github上的工程文件，使用spring initializr来建立工程的框架 https://start.spring.io/
指定各项参数：
Project: 选择使用Maven还是Gradle来管理工程（和依赖）。个人一般使用Maven所以使用Maven Spring Boot 一般选择使用默认的版本 Project Metadata Group 所在组织名，一般是网址的逆序 Artifact 工程的名字，会用于最后生成的jar或者war的命名上 其余自动生成 Packaging 选择最后将工程打包成哪种格式的包 JAVA 选择使用的JAVA版本 Dependencies 选择使用的依赖 指定好各项参数后在下载之前先点击EXPLORE来预览一下生成的POM.xml文件的内容是否正确
使用趁手的编译器来建立工程。我使用的是IDEA IntelliJ，在公司也使用同种编译器体验不错。
Create New Project -&amp;gt; Maven -&amp;gt; Groupd和ArtifactId与之前spring initializr的一致即可，版本因为是demo所以不用太在意如果需要版本方面的知识可以参考语义化版本 -&amp;gt; 接下来选择工程位置即可 然后将spring initializr上下载来的压缩包解压复制里面的POM文件到工程的POM文件中。之后一般IDEA会开始自动下载依赖与构建工程。
从spring initializr下载的压缩包里有个mvnw.cmd文件，里面存储着简易的Maven执行命令脚本（比起mvn命令更简单）。
首先为了可以在IDEA的Terminal中可以运行./mvnw 命令需要安装Maven的运行环境。我是Mac OS所以直接brew install mvn。 然后在工程根目录下（或者直接在IDEA的Terminal中）运行mvn -N io.</description><content type="html"><![CDATA[<p>学习spring的基本知识找不到好的课程所以跟着官方<a href="https://spring.io/guides#getting-started-guides">Guides</a>学习</p>
<p>1.<a href="https://spring.io/guides/gs/rest-service/">建立一个resful服务</a></p>
<ul>
<li>
<p>为了学习基础知识，不使用Github上的工程文件，使用<code>spring initializr</code>来建立工程的框架 <a href="https://start.spring.io/">https://start.spring.io/</a></p>
<ul>
<li>
<p>指定各项参数：</p>
<ul>
<li>Project: 选择使用Maven还是Gradle来管理工程（和依赖）。个人一般使用Maven所以使用Maven</li>
<li>Spring Boot 一般选择使用默认的版本</li>
<li>Project Metadata
<ul>
<li>Group 所在组织名，一般是网址的逆序</li>
<li>Artifact 工程的名字，会用于最后生成的jar或者war的命名上</li>
<li>其余自动生成</li>
</ul>
</li>
<li>Packaging 选择最后将工程打包成哪种格式的包</li>
<li>JAVA 选择使用的JAVA版本</li>
<li>Dependencies 选择使用的依赖</li>
</ul>
</li>
<li>
<p>指定好各项参数后在下载之前先点击<code>EXPLORE</code>来预览一下生成的<code>POM.xml</code>文件的内容是否正确</p>
</li>
</ul>
</li>
<li>
<p>使用趁手的编译器来建立工程。我使用的是IDEA IntelliJ，在公司也使用同种编译器体验不错。</p>
<ul>
<li><code>Create New Project</code> -&gt; <code>Maven</code> -&gt; <code>Groupd</code>和<code>ArtifactId</code>与之前<code>spring initializr</code>的一致即可，版本因为是demo所以不用太在意如果需要版本方面的知识可以参考<a href="https://semver.org/lang/zh-CN/">语义化版本</a> -&gt; 接下来选择工程位置即可</li>
</ul>
</li>
<li>
<p>然后将<code>spring initializr</code>上下载来的压缩包解压复制里面的POM文件到工程的POM文件中。之后一般IDEA会开始自动下载依赖与构建工程。</p>
</li>
<li>
<p>从<code>spring initializr</code>下载的压缩包里有个<code>mvnw.cmd</code>文件，里面存储着简易的Maven执行命令脚本（比起<code>mvn</code>命令更简单）。</p>
<ul>
<li>首先为了可以在IDEA的<code>Terminal</code>中可以运行<code>./mvnw </code>命令需要安装Maven的运行环境。我是Mac OS所以直接<code>brew install mvn</code>。</li>
<li>然后在工程根目录下（或者直接在IDEA的<code>Terminal</code>中）运行<code>mvn -N io.takari:maven:wrapper</code>即可在工程根目录中安装<a href="https://github.com/takari/maven-wrapper">maven-wrapper</a>。</li>
<li>然后运行<code>./mvnw spring-boot:run</code>即可编译打包运行工程一条龙。</li>
</ul>
</li>
<li>
<p>教程中值得注意的点：<code>This application uses the Jackson JSON library to automatically marshal instances of type Greeting into JSON. Jackson is included by default by the web starter.</code></p>
<ul>
<li>意思是Jackson这个可以将JAVA类直接转换成JSON的库已经包含在了<code>Spring Web</code> 中了。</li>
</ul>
</li>
<li>
<p>其他内容都写在教程中了</p>
</li>
</ul>
<p>2.<a href="https://spring.io/guides/gs/consuming-rest/">访问Restful服务</a></p>
<ul>
<li>根据教程即可</li>
</ul>
<p>3.<a href="https://spring.io/guides/gs/maven/">使用Maven建立Java工程</a></p>
<ul>
<li>根据教程即可</li>
</ul>
<p>4.<a href="https://spring.io/guides/gs/uploading-files/">上传文件</a></p>
<ul>
<li>仅凭教程中的代码不足以运行工程，需要根据教程的Github代码来天剑文件存储和例外抛出的类。
<ul>
<li><a href="https://github.com/spring-guides/gs-uploading-files/tree/master/complete/src">教程的示例工程文件</a></li>
</ul>
</li>
</ul>
]]></content></item><item><title>Spring</title><link>/techBlog/posts/spring_restful/</link><pubDate>Sun, 07 Mar 2021 20:57:51 +0900</pubDate><guid>/techBlog/posts/spring_restful/</guid><description>Building REST services with Spring 建立雇员类(Employee.java) 使用JPA的@Entity注解来进行数据存储的准备。 id, name, role都是领域对象模型。其中id被指定为主键并且自动由JPA provider生成。 当需要一个新的员工实例时会创建一个构造函数，但是此时还没有创建id。 使用JPA时建立雇员仓库(EmployeeRepository)来进行与数据库的交互 建立一个接口继承JpaRepository类。domain雷星设置为Employee，id类型设置为long。 仓库式的方法(repository solution)可以回避基于特定语言的数据存储方式。 Spring Boot的入口是一个public static void main类型的，并且在需要Spring Boot行使其作用的地方使用@SpringBootApplication注释。 @SpringBootApplication是一个元注释，用来component scanning, autoconfiguration, and property support。本质就是用来启动一个容器并且使服务开始运行。 建立一个数据交互类LoadDatabase.java 程序做的事： 当Application的内容加载时Spring Boot会运行所有的CommandLineRunner bean。 这个运行类会请求一个EmployeeRepository的拷贝。 建立了两个实体并且存储了它们。 HTTP平台 为了能从网络层获取数据，现在将目光转向Spring MVC。建立控制器类EmployeeController.java。 代码解说 @RestController表示函数返回的结果直接写入响应而不是渲染模板。 EmployeeRepository在controller的构造函数中被注入。 对应HTTP的各种请求方式，存在各种操作的路由。(GET, POST, PUT, and DELETE) EmployeeNotFoundException用来表示查找失败的意外。 在抛出EmployeeNotFoundException例外之后添加Spring MVC的设置(advice)来生成HTTP 404响应。 意外抛出的解说 @ResponseBody表示这个advice直接写入响应体。 @ExceptionHandler指定这个advice只有抛出EmployeeNotFoundException时才会被调用。 @ResponseStatus指定了抛出一个HttpStatus.</description><content type="html"><![CDATA[<h1 id="building-rest-services-with-spring">Building REST services with Spring</h1>
<h2 id="建立雇员类employeejava">建立雇员类(Employee.java)</h2>
<ul>
<li>使用JPA的<code>@Entity</code>注解来进行数据存储的准备。</li>
<li><code>id, name, role</code>都是领域对象模型。其中<code>id</code>被指定为主键并且自动由JPA provider生成。</li>
<li>当需要一个新的员工实例时会创建一个构造函数，但是此时还没有创建<code>id</code>。</li>
</ul>
<h2 id="使用jpa时建立雇员仓库employeerepository来进行与数据库的交互">使用JPA时建立雇员仓库(EmployeeRepository)来进行与数据库的交互</h2>
<ul>
<li>建立一个接口继承<code>JpaRepository</code>类。domain雷星设置为<code>Employee</code>，<code>id</code>类型设置为<code>long</code>。</li>
<li>仓库式的方法(repository solution)可以回避基于特定语言的数据存储方式。</li>
<li>Spring Boot的入口是一个<code>public static void main</code>类型的，并且在需要Spring Boot行使其作用的地方使用<code>@SpringBootApplication</code>注释。
<ul>
<li><code>@SpringBootApplication</code>是一个元注释，用来<code>component scanning, autoconfiguration, and property support</code>。本质就是用来启动一个容器并且使服务开始运行。</li>
</ul>
</li>
</ul>
<h2 id="建立一个数据交互类loaddatabasejava">建立一个数据交互类LoadDatabase.java</h2>
<h3 id="程序做的事">程序做的事：</h3>
<ul>
<li>当Application的内容加载时Spring Boot会运行所有的<code>CommandLineRunner</code> bean。</li>
<li>这个运行类会请求一个<code>EmployeeRepository</code>的拷贝。</li>
<li>建立了两个实体并且存储了它们。</li>
</ul>
<h2 id="http平台">HTTP平台</h2>
<ul>
<li>为了能从网络层获取数据，现在将目光转向Spring MVC。建立控制器类<code>EmployeeController.java</code>。</li>
</ul>
<h3 id="代码解说">代码解说</h3>
<ul>
<li><code>@RestController</code>表示函数返回的结果直接写入响应而不是渲染模板。</li>
<li><code>EmployeeRepository</code>在controller的构造函数中被注入。</li>
<li>对应HTTP的各种请求方式，存在各种操作的路由。(GET, POST, PUT, and DELETE)</li>
<li><code>EmployeeNotFoundException</code>用来表示查找失败的意外。
<ul>
<li>在抛出<code>EmployeeNotFoundException</code>例外之后添加Spring MVC的设置(advice)来生成HTTP 404响应。</li>
</ul>
</li>
</ul>
<h3 id="意外抛出的解说">意外抛出的解说</h3>
<ul>
<li><code>@ResponseBody</code>表示这个advice直接写入响应体。</li>
<li><code>@ExceptionHandler</code>指定这个advice只有抛出<code>EmployeeNotFoundException</code>时才会被调用。</li>
<li><code>@ResponseStatus</code>指定了抛出一个<code>HttpStatus.NOT_FOUND</code>。</li>
<li>advice的函数体用来生成错误信息。这里直接调用了例外的内容。</li>
</ul>
<h2 id="上述达到restful的标准了吗没有">上述达到RESTful的标准了吗？没有</h2>
<h3 id="缺少什么">缺少什么：</h3>
<ul>
<li>类似<code>/employees/3</code>的URL不符合风格。</li>
<li>很少使用GET，POST等。</li>
<li>所有的CRUD都分别映射好。</li>
</ul>
<p>其实上述都是<strong>RPC</strong>（Remote Procedure Call，远程过程调用）。因为无法了解怎么与服务进行交互。还需要额外编写文档。</p>
<h3 id="这里导入spring-hateoas一个可以辅助编写多媒体驱动输出的sping项目">这里导入Spring HATEOAS，一个可以辅助编写多媒体驱动输出的Sping项目。</h3>
<ul>
<li>简而言之关键是需要添加对相关操作的链接（相关资源的路径）
<ul>
<li><code>HAL</code>(Hypertext Application Language)形式是资源(Resources)+链接(Links)
<ul>
<li>链接一般在<code>_links</code>中（JSON格式）</li>
<li>资源中的列表一般在<code>_embedded</code>中（如雇员列表）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="简化的链接生成方式手动使用linkto不赘述">简化的链接生成方式（手动使用<code>linkTo</code>不赘述）</h4>
<ul>
<li>使用HATEOAS的<code>RepresentationModelAssembler&lt;转换前, 转换后&gt;</code>，实现这个接口
<ul>
<li>重写它的方法<code>toModel()</code>来实现将<code>Employee</code>转换为<code>EntityModel&lt;Employee&gt;</code>。</li>
<li>通过<code>@Component</code>注解，应用开始运行时就可以创建这个assembler。</li>
</ul>
</li>
<li>将上述assembler注入控制类中。</li>
</ul>
<h2 id="改进api">改进API</h2>
<ul>
<li>为了保证应用的弹性，需要使API具有即使规格变更也不能影响客户端的特性
<ul>
<li>先导原则：不要删除数据库的列，在RESTful中同样适用。</li>
<li>可以随时加入列</li>
</ul>
</li>
<li>例：将<code>name</code>分解为<code>firstName</code>和<code>lastName</code>
<ul>
<li>数据库新添加两列而不删除原来的</li>
<li>代码解说
<ul>
<li><code>name</code>替换为<code>firstName</code>和<code>lastName</code></li>
<li>获取名字的getter中的方法变为将<code>firstName</code>和<code>lastName</code>进行组合</li>
<li>名字的setter解析输入适当分配</li>
<li>生成初始数据的部分也适当修改</li>
</ul>
</li>
</ul>
</li>
<li>适当地变更响应
<ul>
<li>代码解说
<ul>
<li>同样使用assembler来生成响应体</li>
<li>用<code>ResponseEntity</code>来生成<strong>HTTP 201 Created</strong>状态信息，一般会包含一个<strong>Location</strong>的头，直接用资源自己URI来赋值即可。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="为rest-api创建链接">为REST API创建链接</h2>
<ul>
<li>
<p>主要目的是为了将服务器逻辑与客户端的解析解耦合。</p>
<ul>
<li>比如订单状态
<ul>
<li>处理中→完成/取消</li>
<li>在payload中添加可进行的操作信息容易损坏服务器与客户端的联动并且后续维护成本大</li>
<li>如果客户端可以解析HAL则可以自动显示可以进行的后续操作</li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用的<code>HATEOAS(Hypermedia as the Engine of Application State)</code></p>
<ul>
<li>根据当前状态动态地改变链接列表里的内容</li>
<li>用链接作为应用状态管理的引擎</li>
</ul>
</li>
<li>
<p>具体代码见<a href="https://spring.io/guides/tutorials/rest/">Spring Boot Guide</a></p>
</li>
</ul>
<h3 id="用词">用词</h3>
<ul>
<li><strong>domain object</strong>: A domain class represents a table column and it allows you to handle the column value as a Java object.</li>
</ul>
]]></content></item><item><title>Udemy Docker learning</title><link>/techBlog/posts/docker_learning/</link><pubDate>Sun, 07 Mar 2021 19:53:41 +0900</pubDate><guid>/techBlog/posts/docker_learning/</guid><description>Section3 执行启动容器命令之后会发生什么 执行docker container run --publish 80:80 --name webhost --detach nginx之后发生的：
在本地的image cache中寻找 如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub） 下载寻找到的image最新版本 以下载好的image为基础创建一个容器container 在docker engine的private network中创建一个虚拟IP 打开主机（host）的80端口连接转发至容器的80端口 如果不用--publish选项则不会打开任何端口 使用image Dockerfile中的CMD启动容器 --detach使得container在后台运行，不接收输入与输出。 重新进入交互模式使用docker attach(需要有正在运行的bash，退出container也停止)，或者docker exec -it(退出container不停止) 参考1 参考2 Container VS. VM container不是mini VM（与VM基本没有相似之处） 只是进程（process） 被限制在其能访问的资源中 进程停止则退出 相关命令解说 docker top列出在特定的容器中执行的进程 ps aux可以发现同样的进程可以在主机系统中查询到 所以容器是一个进程
监视 docker container top 同上 docker container inspect列出启动容器时所用的设置（JSON格式）等元数据 docker container stats监视容器运行状态（CPU使用和内存等） 进入容器内部 docker container run -it以交互的方式启动容器 -t创建一个虚拟的tty -i使得会话开放来接收终端输入（keep session open to receive terminal input） 末尾可以加入想运行的命令，比如bash e.</description><content type="html"><![CDATA[<h1 id="section3">Section3</h1>
<h2 id="执行启动容器命令之后会发生什么">执行启动容器命令之后会发生什么</h2>
<p>执行<code>docker container run --publish 80:80 --name webhost --detach nginx</code>之后发生的：</p>
<ol>
<li>在本地的image cache中寻找</li>
<li>如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub）</li>
<li>下载寻找到的image最新版本</li>
<li>以下载好的image为基础创建一个容器container</li>
<li>在docker engine的private network中创建一个虚拟IP</li>
<li>打开主机（host）的80端口连接转发至容器的80端口
<ul>
<li>如果不用<code>--publish</code>选项则不会打开任何端口</li>
</ul>
</li>
<li>使用image Dockerfile中的CMD启动容器</li>
<li><code>--detach</code>使得container在后台运行，不接收输入与输出。</li>
</ol>
<ul>
<li>重新进入交互模式使用<code>docker attach</code>(需要有正在运行的bash，退出container也停止)，或者<code>docker exec -it</code>(退出container不停止)</li>
<li><a href="https://qiita.com/RyoMa_0923/items/9b5d2c4a97205692a560">参考1</a></li>
<li><a href="https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec">参考2</a></li>
</ul>
<h2 id="container-vs-vm">Container VS. VM</h2>
<h3 id="container不是mini-vm与vm基本没有相似之处">container不是mini VM（与VM基本没有相似之处）</h3>
<ul>
<li>只是进程（process）</li>
<li>被限制在其能访问的资源中</li>
<li>进程停止则退出</li>
</ul>
<h4 id="相关命令解说">相关命令解说</h4>
<p><code>docker top</code>列出在特定的容器中执行的进程
<code>ps aux</code>可以发现同样的进程可以在主机系统中查询到
所以容器是一个进程</p>
<h2 id="监视">监视</h2>
<ul>
<li><code>docker container top</code> 同上</li>
<li><code>docker container inspect</code>列出启动容器时所用的设置（JSON格式）等元数据</li>
<li><code>docker container stats</code>监视容器运行状态（CPU使用和内存等）</li>
</ul>
<h2 id="进入容器内部">进入容器内部</h2>
<ul>
<li><code>docker container run -it</code>以交互的方式启动容器
<ul>
<li><code>-t</code>创建一个虚拟的tty</li>
<li><code>-i</code>使得会话开放来接收终端输入（keep session open to receive terminal input）</li>
<li>末尾可以加入想运行的命令，比如<code>bash</code></li>
<li>e.g. <code>docker container run --name nginx -it nginx bash</code>直接进入容器的终端
<ul>
<li>退出后容器停止</li>
</ul>
</li>
</ul>
</li>
<li><code>docker container exec -it &lt;command&gt;</code>在既存的运行中的容器中以交互方式执行命令
<ul>
<li>不影响容器运行</li>
<li>需要启动容器来执行否则会报错</li>
</ul>
</li>
<li>Alpine是一个很小的linux发行版本，只有<code>sh</code>，可以通过<code>apk</code>来安装<code>bash</code></li>
</ul>
<h2 id="容器的网络">容器的网络</h2>
<h3 id="网络默认设置">网络默认设置</h3>
<ul>
<li>每个容器都连接到一个虚拟私有网络<code>bridge</code></li>
<li>每个虚拟网络都通过NAT防火墙路由至主机IP
<ul>
<li>每个容器可以通过这个路径连接到外面的网络再连接回来</li>
</ul>
</li>
<li>容器之间的通讯不需要<code>-p</code>的设置也可以实现
<ul>
<li>如一个由mysql, php/apache组成的<code>my_web_app</code>网络</li>
<li>和一个由mongo, nodejs组成的<code>my_api</code>网络</li>
<li>但是不进行设置的话不同网络之间没法互通</li>
</ul>
</li>
</ul>
<h3 id="定制化">定制化</h3>
<ul>
<li>&ldquo;Batteris included, But Removable&rdquo;
<ul>
<li>大部分情景使用默认设置即可但是可以随意定制</li>
</ul>
</li>
<li>可以将容器连接至多个或0个虚拟网络</li>
<li>可使用<code>--net=host</code>来跳过虚拟网络直接使用主机IP</li>
<li>在主机级别的端口，一个端口只能被一个容器所监听</li>
</ul>
<h3 id="代码">代码</h3>
<ul>
<li><code>-p</code>命令后的格式是<code>HOST:CONTAINER</code></li>
<li><code>docker container port &lt;container&gt;</code>显示端口映射情况</li>
<li>查看容器地址<code>docker container inspect --format &quot;{{ .NetworkSettings.IPAddress}}&quot; &lt;container&gt;</code></li>
</ul>
<h3 id="命令行管理网络">命令行管理网络</h3>
<ul>
<li><code>docker network ls</code>列出所有虚拟网络
<ul>
<li>bridge(docker0)是通过NAT防火墙连接至主机物理网络的默认网络</li>
<li>host是跳过docker的直接与主机网络接口连接的网络，牺牲了容器模式下的安全性换来了更高的网络性能</li>
<li>none:不与任何外部接口相连（eth0），只留有容器内部的localhost接口</li>
</ul>
</li>
<li><code>docker network inspect bridge</code>查看bridge网络的详情
<ul>
<li>可以看到有哪些容器连接在这个网络上</li>
<li><code>IPAM</code>可以看到网络设置，最后通过网关连接到主机物理网络</li>
</ul>
</li>
<li><code>docker network create &lt;name&gt;</code>使用bridge的驱动（默认的）创建一个虚拟网络</li>
<li>启动（run）容器时可以用<code>--network</code>来指定网络</li>
<li><code>docker network connect/disconnect &lt;network&gt; &lt;container&gt;</code>将容器连接至/断开网络连接</li>
</ul>
<h3 id="dns">DNS</h3>
<p>dcoker自带一个DNS用来解析域名（容器名）从而访问到正确的容器（使用相当于hostname的container name来实现容器之间的通讯）</p>
<ul>
<li>新建一个虚拟网络，当使用<code>--network</code>来将不通的容器连接至虚拟网络时，或自动以容器名为key来建立DNS服务，这样同一个虚拟网络之间的容器就可以互相连通</li>
<li>默认的<code>bridge</code>虚拟网络没有这种服务，每次添加新的容器如果需要与其他容器连接则需要手动使用<code>--link &lt;list of container&gt;</code>来设置</li>
</ul>
<h1 id="section4-image">Section4 Image</h1>
<h2 id="什么是image-包括">什么是Image （包括）</h2>
<ul>
<li>应用的二进制和依赖文件数据</li>
<li>image data的元数据和如何运行image的设定参数</li>
</ul>
<h2 id="image-layers">Image layers</h2>
<ul>
<li>
<p><code>docker image history</code> 显示Image layer的历史</p>
<ul>
<li>除了第一个履历有Image ID之外其他都为<!-- raw HTML omitted -->, 因为其他的layer只是构成Image的一部分并不是Image本身，所以不配拥有ID。</li>
</ul>
</li>
<li>
<p>每个Image都从成为scratch的空layer开始，在这之后发生在Image的文件系统中的改变都是一个layer
<img src="https://github.com/ACGNM/pics/raw/master/docker/image_layers.png" alt="例图">
<img src="https://github.com/ACGNM/pics/raw/master/docker/custom_image.png" alt="例图">
<img src="https://github.com/ACGNM/pics/raw/master/docker/copy_on_write.png" alt="pic"></p>
</li>
<li>
<p><code>docker image inspect</code> 取得Image的metadata (Image如何运行，Image的JSON格式的详细信息)</p>
</li>
</ul>
<h2 id="image-tag">image tag</h2>
<ul>
<li><code>dokcer image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code>
<ul>
<li><code>docker image tag --help</code>来查看用法</li>
<li>根据SOURCE_IMAGE(with tag <code>TAG</code>)来创建一个TARGET_IMAGE（默认tag为latest）</li>
<li>总是创建一个新记录（对于执行 <code>docker image ls</code>的结果）</li>
</ul>
</li>
<li>只是一个用来区分的名称。如nginx的latest和mainline是拥有同一个image ID的image。都pull下来时，pull第二个会显示已经存在。但是在<code>docker image ls</code>中分开显示（同时可以发现两者image ID相同）</li>
<li>默认的tag是<code>latest</code>。但并不代表就是最新的</li>
<li><code>docker image push</code>可以向Docker Hub上传变更过layer的image
<ul>
<li>这之前需要先登陆。使用<code>docker login</code></li>
<li>在<code>./docker/config.json</code>中存储docker Hub的认证信息
如果想上传一个私人（private）的image，则先需要建立一个私人仓库然后再上传</li>
</ul>
</li>
</ul>
<h2 id="dockerfile基础">Dockerfile基础</h2>
<h3 id="参考dockerfile-sample-1注释">参考dockerfile-sample-1注释</h3>
<ul>
<li><a href="https://github.com/BretFisher/udemy-docker-mastery/blob/main/dockerfile-sample-1/Dockerfile">dockerfile-sample-1</a></li>
<li><a href="https://docs.docker.com/engine/reference/builder/#usage">官方相关文档</a></li>
</ul>
<h3 id="建立image-building-image">建立Image (building Image)</h3>
<ul>
<li>首先改变当前目录至存在<code>Dockerfile</code>的目录中
<ul>
<li>如果想使用非默认名称 (Dockerfile) 的dockerfile, 使用<code>-f</code>选项 (<code>docker image build -f &lt;dockerfile_name&gt;</code>)</li>
</ul>
</li>
<li><code>docker image build -t IMAGE_NAME[:TAG] &lt;path&gt;</code>
<ul>
<li>如果只是本地使用，则不需要在前面加上Docker Hub的account name</li>
</ul>
</li>
<li>接下来的输出对应Dockerfile的每一个stanza的命令
<ul>
<li>每一步会对应一个存在build Cache中的Hash用来标记每一步</li>
<li>如果下一次build时Dockerfile的对应那一行没有变化则不会再执行一边相同的stanza</li>
<li>如果有所该表则重新执行有变化的stanza及其之后的所有stanza</li>
<li>Docker的build快速是因为docker将每一步都放入缓存中</li>
</ul>
</li>
<li>扩展官方image
<ul>
<li>使用  <a href="https://github.com/BretFisher/udemy-docker-mastery/blob/main/dockerfile-sample-2">dockerfile-sample-2</a></li>
<li>可以直接<code>FROM</code>官方的Image来加入自定义设置</li>
<li>可以继承来<code>FROM</code>里的所有stanza，所以不需要加入<code>CMD</code>等必要的stanza</li>
<li><code>WORKDIR</code>相当于执行了<code>cd</code>命令</li>
<li><code>docker conainer run</code>的<code>-rm</code>flag用来告诉docker，当container退出后clean up container和其file system</li>
</ul>
</li>
</ul>
<h1 id="section5-container生命周期和持久数据volumes">Section5 Container生命周期和持久数据（Volumes）</h1>
<h2 id="container-lifetime">Container Lifetime</h2>
<ul>
<li>container一般具有不变性和临时性</li>
<li>&ldquo;immutable infrastructure&rdquo;: only re-deploy, never change
<ul>
<li>这是理想的状态，应用的二进制应该与数据分开</li>
<li>当应用升级时只需要重新部署一个有着升过级的app的container并且会包含所有之前的专有数据（unique data）</li>
<li>这种特性由Docker提供，保证这种&quot;separation concerns&quot;</li>
</ul>
</li>
<li>在删除container之前，跨越关闭和重启的那些专有数据（在UFS层-union file system）可以称为&quot;persistent data&quot;
<ul>
<li>在container之前还没有这种概念。因为以前的服务器的数据默认就是持续存在的</li>
<li>在container和auto scaling的世界就会出现如何维护这种unique data的问题</li>
<li>为了解决这个问题, Docker中有两个解决方案，<code>Volumes</code>和<code>Bind Mounts</code></li>
</ul>
</li>
<li><code>Volumes</code>: make special location outside of container UFS to store unique data</li>
<li><code>Bind Mounts</code>: link container path to host path</li>
<li>在上述两种情况下，在container看来都是达到了在访问本地路径一样的效果</li>
</ul>
<h2 id="data-volumes">Data Volumes</h2>
]]></content></item></channel></rss>