<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="在class中访问元素 使用attr_accessor :foo 定义的变量foo可以不需要self.直接访问。 如
class Person attr_accessor :name def greeting name end end &amp;gt;&amp;gt; person = Person.new &amp;gt;&amp;gt; person.name = &amp;quot;maiomi&amp;quot; &amp;gt;&amp;gt; person.greeting =&amp;gt; &amp;quot;miaomi&amp;quot; 教程中解释上述现象的语句为： is created automatically by Active Record based on the name of the corresponding database column
可以不带self.取得但是如果更新不带self.的话就会建立一个函数的本地变量，不会对类的属性产生影响。 如
class Person attr_accessor :name def greeting(string) name = string end end &amp;gt;&amp;gt; person = Person.new &amp;gt;&amp;gt; person.greeting(&amp;quot;miaomi&amp;quot;) =&amp;gt; &amp;quot;miaomi&amp;quot; &amp;gt;&amp;gt; person.name =&amp;gt; nil 使用self.之后
class Person attr_accessor :name def greeting(string) self."><meta name=keywords content=",ruby"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=/techBlog/posts/ruby_on_rails_tips/><title>Ruby_on_rails_tips :: Day Day Up</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=/techBlog/main.d7bdd8ee18bfbf4c605488a7e5b1b92cd980dfeed2bdaeab4dd5e931a7a78bc0.css><meta itemprop=name content="Ruby_on_rails_tips"><meta itemprop=description content="在class中访问元素 使用attr_accessor :foo 定义的变量foo可以不需要self.直接访问。 如
class Person attr_accessor :name def greeting name end end >> person = Person.new >> person.name = &#34;maiomi&#34; >> person.greeting => &#34;miaomi&#34; 教程中解释上述现象的语句为： is created automatically by Active Record based on the name of the corresponding database column
可以不带self.取得但是如果更新不带self.的话就会建立一个函数的本地变量，不会对类的属性产生影响。 如
class Person attr_accessor :name def greeting(string) name = string end end >> person = Person.new >> person.greeting(&#34;miaomi&#34;) => &#34;miaomi&#34; >> person.name => nil 使用self.之后
class Person attr_accessor :name def greeting(string) self."><meta itemprop=datePublished content="2021-03-07T21:22:31+09:00"><meta itemprop=dateModified content="2021-03-07T21:22:31+09:00"><meta itemprop=wordCount content="220"><meta itemprop=keywords content="ruby,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ruby_on_rails_tips"><meta name=twitter:description content="在class中访问元素 使用attr_accessor :foo 定义的变量foo可以不需要self.直接访问。 如
class Person attr_accessor :name def greeting name end end >> person = Person.new >> person.name = &#34;maiomi&#34; >> person.greeting => &#34;miaomi&#34; 教程中解释上述现象的语句为： is created automatically by Active Record based on the name of the corresponding database column
可以不带self.取得但是如果更新不带self.的话就会建立一个函数的本地变量，不会对类的属性产生影响。 如
class Person attr_accessor :name def greeting(string) name = string end end >> person = Person.new >> person.greeting(&#34;miaomi&#34;) => &#34;miaomi&#34; >> person.name => nil 使用self.之后
class Person attr_accessor :name def greeting(string) self."><meta property="article:published_time" content="2021-03-07 21:22:31 +0900 +0900"></head><body><div class=container><header class=header><span class=header__inner><a href=/techBlog style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$cd /home/zgong</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/techBlog/posts>Blog</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 minutes</p></div><article><h1 class=post-title><a href=/techBlog/posts/ruby_on_rails_tips/>Ruby_on_rails_tips</a></h1><div class=post-content><h3 id=在class中访问元素>在class中访问元素</h3><p>使用<code>attr_accessor :foo</code> 定义的变量<code>foo</code>可以不需要<code>self.</code>直接访问。
如</p><pre><code>class Person
  attr_accessor :name
  
  def greeting
    name
  end
end

&gt;&gt; person = Person.new
&gt;&gt; person.name = &quot;maiomi&quot;
&gt;&gt; person.greeting
=&gt; &quot;miaomi&quot;
</code></pre><p>教程中解释上述现象的语句为：
<code>is created automatically by Active Record based on the name of the corresponding database column</code></p><p>可以不带<code>self.</code>取得但是如果更新不带<code>self.</code>的话就会建立一个函数的本地变量，不会对类的属性产生影响。
如</p><pre><code>class Person
  attr_accessor :name

  def greeting(string)
    name = string
  end
end

&gt;&gt; person = Person.new
&gt;&gt; person.greeting(&quot;miaomi&quot;)
=&gt; &quot;miaomi&quot;
&gt;&gt; person.name
=&gt; nil
</code></pre><p>使用<code>self.</code>之后</p><pre><code>class Person
  attr_accessor :name

  def greeting(string)
    self.name = string
  end
end

&gt;&gt; person = Person.new
&gt;&gt; person.greeting(&quot;miaomi&quot;)
=&gt; &quot;miaomi&quot;
&gt;&gt; person.name
=&gt; &quot;miaomi&quot;
</code></pre><h3 id=bcryptpassword的用法>BCrypt::Password的用法</h3><p>判断数据库中的加密过的密码是否与提交的密码匹配，使用处理如下：</p><pre><code>BCrypt::Password.new(remember_digest).is_password?(remember_token)

or 

BCrypt::Password.new(remember_digest) == (remember_token)
</code></pre><p>这里的<code>==</code>被重写过，将提交的password加密后与数据库中的被加密过的密码比较
参考：
<a href=https://github.com/codahale/bcrypt-ruby/blob/9f3fb05ba7b3732a87e0305ec635d7773bf1fafb/lib/bcrypt/password.rb#L66>https://github.com/codahale/bcrypt-ruby/blob/9f3fb05ba7b3732a87e0305ec635d7773bf1fafb/lib/bcrypt/password.rb#L66</a>
使用例：
<a href=https://www.rubydoc.info/github/codahale/bcrypt-ruby/BCrypt/Password>https://www.rubydoc.info/github/codahale/bcrypt-ruby/BCrypt/Password</a></p><h3 id=在不同网页标签中登录同一用户其中一个登出后另一个再登出出现actioncontrollerinvalidauthenticitytoken错误>在不同网页标签中登录同一用户，其中一个登出后另一个再登出出现<code>ActionController::InvalidAuthenticityToken</code>错误</h3><p>修复方法参考
<a href=https://qiita.com/_ayk_study/items/88269643c675fd4ca975>https://qiita.com/_ayk_study/items/88269643c675fd4ca975</a></p><h3 id=其他零碎的知识>其他零碎的知识</h3><ol><li></li></ol><pre><code>User.find_by(id: cookies.encrypted[:user_id])
</code></pre><p>where cookies.encrypted[:user_id] automatically decrypts the user id cookie.</p><ol start=2><li></li></ol><p>不带<code>@</code>的变量是普通（非实例）变量 -> <code>normal (non-instance) variable</code>
在测试中不能用<code>assigns(:foo)</code>来获取</p><ol start=3><li></li></ol><p><code>session</code> method are automatically encrypted
参考
<a href=https://stackoverflow.com/questions/39601527/how-session-works-in-rails>https://stackoverflow.com/questions/39601527/how-session-works-in-rails</a></p><ol start=4><li></li></ol><p>so how does Rails know to use a POST request for new users and a PATCH for editing users? The answer is that it is possible to tell whether a user is new or already exists in the database via Active Record’s new_record? boolean method:</p><pre><code>$ rails console
&gt;&gt; User.new.new_record?
=&gt; true
&gt;&gt; User.first.new_record?
=&gt; false
</code></pre><p>When constructing a form using form_with(@user), Rails uses POST if @user.new_record? is true and PATCH if it is false.</p><ol start=5><li></li></ol><p>使用<code>target="_blank"</code>进行跳转时的安全问题。
<a href=https://imququ.com/post/the-security-of-window-opener-location.html>https://imququ.com/post/the-security-of-window-opener-location.html</a></p><ol start=6><li></li></ol><p>fixture中的用户保存时不会被model中的<code>before_save</code>限制，就导致如果大小写不注意的话测试中的登陆会失败。</p><ol start=7><li></li></ol><p><code>belongs_to</code>的<code>foreign_key:</code>和<code>primary_key:</code>选项
<code>foreign_key:</code>指定自己存储外键的行（column）的名称
<code>primary_key:</code>指定自己存储外键的行中的值来自从属model的哪一行（column）</p><p><code>has_many</code>的<code>foreign_key:</code>和<code>primary_key:</code>选项
<code>foreign_key:</code>指定子类存储外键的行（column）的名称
<code>primary_key:</code>指定子类存储外键的行中的值来自自己的哪一行（column）</p><p>问题：
polymorphic_path 生成的路径会有单数的时候
如/article_latest/1
答：参考下面（用单数重写的话就会保持单数）
<a href=https://stackoverflow.com/questions/23931120/how-does-form-for-generate-paths-in-rails>https://stackoverflow.com/questions/23931120/how-does-form-for-generate-paths-in-rails</a></p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=/techBlog/tags/ruby/>ruby</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><path d="M14 2H6A2 2 0 004 4v16a2 2 0 002 2h12a2 2 0 002-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>220 Words</p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>2021-03-07 12:22</p></div><div class=pagination><div class=pagination__title><span class=pagination__title-h></span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/techBlog/posts/udemy_linux/><span class=button__icon>←</span>
<span class=button__text>Udemy_linux</span></a></span>
<span class="button next"><a href=/techBlog/posts/sprint_guide/><span class=button__text>Sprint_guide</span>
<span class=button__icon>→</span></a></span></div></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2021</span>
<span><a href=/techBlog/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://acgnm.github.io/techBlog>zgong</a></span></div></div></footer></div><script type=text/javascript src=/techBlog/bundle.min.2ce64ea6ea44a72b13dd812fc2eb5cca3efe878cce258a47c137c17edf46e0602a05e422b618a5b80b5939c731b7a293351c2f2222a21f6ee27e54a8448dd20e.js integrity="sha512-LOZOpupEpysT3YEvwutcyj7+h4zOJYpHwTfBft9G4GAqBeQithiluAtZOccxt6KTNRwvIiKiH27iflSoRI3SDg=="></script></body></html>