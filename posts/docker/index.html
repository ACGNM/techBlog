<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Docker Learning | Day Day Up</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Section3 执行启动容器命令之后会发生什么 执行docker container run --publish 80:80 --name webhost --detach nginx之后发生的：
 在本地的image cache中寻找 如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub） 下载寻找到的image最新版本 以下载好的image为基础创建一个容器container 在docker engine的private network中创建一个虚拟IP 打开主机（host）的80端口连接转发至容器的80端口  如果不用--publish选项则不会打开任何端口   使用image Dockerfile中的CMD启动容器 --detach使得container在后台运行，不接收输入与输出。   重新进入交互模式使用docker attach(需要有正在运行的bash，退出container也停止)，或者docker exec -it(退出container不停止) 参考1 参考2  Container VS. VM container不是mini VM（与VM基本没有相似之处）  只是进程（process） 被限制在其能访问的资源中 进程停止则退出  相关命令解说 docker top列出在特定的容器中执行的进程 ps aux可以发现同样的进程可以在主机系统中查询到 所以容器是一个进程
监视  docker container top 同上 docker container inspect列出启动容器时所用的设置（JSON格式）等元数据 docker container stats监视容器运行状态（CPU使用和内存等）  进入容器内部  docker container run -it以交互的方式启动容器  -t创建一个虚拟的tty -i使得会话开放来接收终端输入（keep session open to receive terminal input） 末尾可以加入想运行的命令，比如bash e."><meta name=generator content="Hugo 0.81.0"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/techBlog/ananke/dist/main.css_5c99d70a7725bacd4c701e995b969fea.css><meta property="og:title" content="Docker Learning"><meta property="og:description" content="Section3 执行启动容器命令之后会发生什么 执行docker container run --publish 80:80 --name webhost --detach nginx之后发生的：
 在本地的image cache中寻找 如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub） 下载寻找到的image最新版本 以下载好的image为基础创建一个容器container 在docker engine的private network中创建一个虚拟IP 打开主机（host）的80端口连接转发至容器的80端口  如果不用--publish选项则不会打开任何端口   使用image Dockerfile中的CMD启动容器 --detach使得container在后台运行，不接收输入与输出。   重新进入交互模式使用docker attach(需要有正在运行的bash，退出container也停止)，或者docker exec -it(退出container不停止) 参考1 参考2  Container VS. VM container不是mini VM（与VM基本没有相似之处）  只是进程（process） 被限制在其能访问的资源中 进程停止则退出  相关命令解说 docker top列出在特定的容器中执行的进程 ps aux可以发现同样的进程可以在主机系统中查询到 所以容器是一个进程
监视  docker container top 同上 docker container inspect列出启动容器时所用的设置（JSON格式）等元数据 docker container stats监视容器运行状态（CPU使用和内存等）  进入容器内部  docker container run -it以交互的方式启动容器  -t创建一个虚拟的tty -i使得会话开放来接收终端输入（keep session open to receive terminal input） 末尾可以加入想运行的命令，比如bash e."><meta property="og:type" content="article"><meta property="og:url" content="https://acgnm.github.io/techBlog/posts/docker/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-07T17:45:27+09:00"><meta property="article:modified_time" content="2021-03-07T17:45:27+09:00"><meta itemprop=name content="Docker Learning"><meta itemprop=description content="Section3 执行启动容器命令之后会发生什么 执行docker container run --publish 80:80 --name webhost --detach nginx之后发生的：
 在本地的image cache中寻找 如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub） 下载寻找到的image最新版本 以下载好的image为基础创建一个容器container 在docker engine的private network中创建一个虚拟IP 打开主机（host）的80端口连接转发至容器的80端口  如果不用--publish选项则不会打开任何端口   使用image Dockerfile中的CMD启动容器 --detach使得container在后台运行，不接收输入与输出。   重新进入交互模式使用docker attach(需要有正在运行的bash，退出container也停止)，或者docker exec -it(退出container不停止) 参考1 参考2  Container VS. VM container不是mini VM（与VM基本没有相似之处）  只是进程（process） 被限制在其能访问的资源中 进程停止则退出  相关命令解说 docker top列出在特定的容器中执行的进程 ps aux可以发现同样的进程可以在主机系统中查询到 所以容器是一个进程
监视  docker container top 同上 docker container inspect列出启动容器时所用的设置（JSON格式）等元数据 docker container stats监视容器运行状态（CPU使用和内存等）  进入容器内部  docker container run -it以交互的方式启动容器  -t创建一个虚拟的tty -i使得会话开放来接收终端输入（keep session open to receive terminal input） 末尾可以加入想运行的命令，比如bash e."><meta itemprop=datePublished content="2021-03-07T17:45:27+09:00"><meta itemprop=dateModified content="2021-03-07T17:45:27+09:00"><meta itemprop=wordCount content="253"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker Learning"><meta name=twitter:description content="Section3 执行启动容器命令之后会发生什么 执行docker container run --publish 80:80 --name webhost --detach nginx之后发生的：
 在本地的image cache中寻找 如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub） 下载寻找到的image最新版本 以下载好的image为基础创建一个容器container 在docker engine的private network中创建一个虚拟IP 打开主机（host）的80端口连接转发至容器的80端口  如果不用--publish选项则不会打开任何端口   使用image Dockerfile中的CMD启动容器 --detach使得container在后台运行，不接收输入与输出。   重新进入交互模式使用docker attach(需要有正在运行的bash，退出container也停止)，或者docker exec -it(退出container不停止) 参考1 参考2  Container VS. VM container不是mini VM（与VM基本没有相似之处）  只是进程（process） 被限制在其能访问的资源中 进程停止则退出  相关命令解说 docker top列出在特定的容器中执行的进程 ps aux可以发现同样的进程可以在主机系统中查询到 所以容器是一个进程
监视  docker container top 同上 docker container inspect列出启动容器时所用的设置（JSON格式）等元数据 docker container stats监视容器运行状态（CPU使用和内存等）  进入容器内部  docker container run -it以交互的方式启动容器  -t创建一个虚拟的tty -i使得会话开放来接收终端输入（keep session open to receive terminal input） 末尾可以加入想运行的命令，比如bash e."></head><body class="ma0 avenir bg-near-white"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/techBlog/ class="f3 fw2 hover-white no-underline white-90 dib">Day Day Up</a><div class="flex-l items-center"></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class=mt3><a href="https://www.facebook.com/sharer.php?u=https://acgnm.github.io/techBlog/posts/docker/" class="facebook no-underline" aria-label="share on Facebook"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M28.765 50.32h6.744V33.998h4.499l.596-5.624h-5.095l.007-2.816c0-1.466.14-2.253 2.244-2.253h2.812V17.68h-4.5c-5.405.0-7.307 2.729-7.307 7.317v3.377h-3.369v5.625h3.369V50.32zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd"/></svg></a><a href="https://twitter.com/share?url=https://acgnm.github.io/techBlog/posts/docker/&text=Docker%20Learning" class="twitter no-underline" aria-label="share on Twitter"><svg height="32" style="enable-background:new 0 0 67 67" viewBox="0 0 67 67" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M37.167 22.283c-2.619.953-4.274 3.411-4.086 6.101l.063 1.038-1.048-.127c-3.813-.487-7.145-2.139-9.974-4.915l-1.383-1.377-.356 1.017c-.754 2.267-.272 4.661 1.299 6.271.838.89.649 1.017-.796.487-.503-.169-.943-.296-.985-.233-.146.149.356 2.076.754 2.839.545 1.06 1.655 2.097 2.871 2.712l1.027.487-1.215.021c-1.173.0-1.215.021-1.089.467.419 1.377 2.074 2.839 3.918 3.475l1.299.444-1.131.678c-1.676.976-3.646 1.526-5.616 1.568C19.775 43.256 19 43.341 19 43.405c0 .211 2.557 1.397 4.044 1.864 4.463 1.377 9.765.783 13.746-1.568 2.829-1.673 5.657-5 6.978-8.221.713-1.716 1.425-4.851 1.425-6.354.0-.975.063-1.102 1.236-2.267.692-.678 1.341-1.419 1.467-1.631.21-.403.188-.403-.88-.043-1.781.636-2.033.551-1.152-.402.649-.678 1.425-1.907 1.425-2.267.0-.063-.314.042-.671.233-.377.212-1.215.53-1.844.72l-1.131.361-1.027-.7c-.566-.381-1.361-.805-1.781-.932C39.766 21.902 38.131 21.944 37.167 22.283zM33 64C16.432 64 3 50.569 3 34S16.432 4 33 4s30 13.431 30 30S49.568 64 33 64z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a><a href="https://www.linkedin.com/shareArticle?mini=true&url=https://acgnm.github.io/techBlog/posts/docker/&title=Docker%20Learning" class="linkedin no-underline" aria-label="share on LinkedIn"><svg height="32" style="enable-background:new 0 0 65 65" viewBox="0 0 65 65" width="32" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path d="M50.837 48.137V36.425c0-6.275-3.35-9.195-7.816-9.195-3.604.0-5.219 1.983-6.119 3.374V27.71h-6.79c.09 1.917.0 20.427.0 20.427h6.79V36.729c0-.609.044-1.219.224-1.655.49-1.22 1.607-2.483 3.482-2.483 2.458.0 3.44 1.873 3.44 4.618v10.929H50.837zM22.959 24.922c2.367.0 3.842-1.57 3.842-3.531-.044-2.003-1.475-3.528-3.797-3.528s-3.841 1.524-3.841 3.528c0 1.961 1.474 3.531 3.753 3.531H22.959zM34 64C17.432 64 4 50.568 4 34 4 17.431 17.432 4 34 4s30 13.431 30 30c0 16.568-13.432 30-30 30zM26.354 48.137V27.71h-6.789v20.427h6.789z" style="fill-rule:evenodd;clip-rule:evenodd;fill:"/></svg></a></div><h1 class="f1 athelas mt3 mb1">Docker Learning</h1><time class="f6 mv4 dib tracked" datetime=2021-03-07T17:45:27+09:00>March 7, 2021</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><h1 id=section3>Section3</h1><h2 id=执行启动容器命令之后会发生什么>执行启动容器命令之后会发生什么</h2><p>执行<code>docker container run --publish 80:80 --name webhost --detach nginx</code>之后发生的：</p><ol><li>在本地的image cache中寻找</li><li>如果本地找不到匹配的image，则在远程的image repo中寻找（默认为Docker Hub）</li><li>下载寻找到的image最新版本</li><li>以下载好的image为基础创建一个容器container</li><li>在docker engine的private network中创建一个虚拟IP</li><li>打开主机（host）的80端口连接转发至容器的80端口<ul><li>如果不用<code>--publish</code>选项则不会打开任何端口</li></ul></li><li>使用image Dockerfile中的CMD启动容器</li><li><code>--detach</code>使得container在后台运行，不接收输入与输出。</li></ol><ul><li>重新进入交互模式使用<code>docker attach</code>(需要有正在运行的bash，退出container也停止)，或者<code>docker exec -it</code>(退出container不停止)</li><li><a href=https://qiita.com/RyoMa_0923/items/9b5d2c4a97205692a560>参考1</a></li><li><a href=https://stackoverflow.com/questions/30960686/difference-between-docker-attach-and-docker-exec>参考2</a></li></ul><h2 id=container-vs-vm>Container VS. VM</h2><h3 id=container不是mini-vm与vm基本没有相似之处>container不是mini VM（与VM基本没有相似之处）</h3><ul><li>只是进程（process）</li><li>被限制在其能访问的资源中</li><li>进程停止则退出</li></ul><h4 id=相关命令解说>相关命令解说</h4><p><code>docker top</code>列出在特定的容器中执行的进程
<code>ps aux</code>可以发现同样的进程可以在主机系统中查询到
所以容器是一个进程</p><h2 id=监视>监视</h2><ul><li><code>docker container top</code> 同上</li><li><code>docker container inspect</code>列出启动容器时所用的设置（JSON格式）等元数据</li><li><code>docker container stats</code>监视容器运行状态（CPU使用和内存等）</li></ul><h2 id=进入容器内部>进入容器内部</h2><ul><li><code>docker container run -it</code>以交互的方式启动容器<ul><li><code>-t</code>创建一个虚拟的tty</li><li><code>-i</code>使得会话开放来接收终端输入（keep session open to receive terminal input）</li><li>末尾可以加入想运行的命令，比如<code>bash</code></li><li>e.g. <code>docker container run --name nginx -it nginx bash</code>直接进入容器的终端<ul><li>退出后容器停止</li></ul></li></ul></li><li><code>docker container exec -it &lt;command></code>在既存的运行中的容器中以交互方式执行命令<ul><li>不影响容器运行</li><li>需要启动容器来执行否则会报错</li></ul></li><li>Alpine是一个很小的linux发行版本，只有<code>sh</code>，可以通过<code>apk</code>来安装<code>bash</code></li></ul><h2 id=容器的网络>容器的网络</h2><h3 id=网络默认设置>网络默认设置</h3><ul><li>每个容器都连接到一个虚拟私有网络<code>bridge</code></li><li>每个虚拟网络都通过NAT防火墙路由至主机IP<ul><li>每个容器可以通过这个路径连接到外面的网络再连接回来</li></ul></li><li>容器之间的通讯不需要<code>-p</code>的设置也可以实现<ul><li>如一个由mysql, php/apache组成的<code>my_web_app</code>网络</li><li>和一个由mongo, nodejs组成的<code>my_api</code>网络</li><li>但是不进行设置的话不同网络之间没法互通</li></ul></li></ul><h3 id=定制化>定制化</h3><ul><li>&ldquo;Batteris included, But Removable&rdquo;<ul><li>大部分情景使用默认设置即可但是可以随意定制</li></ul></li><li>可以将容器连接至多个或0个虚拟网络</li><li>可使用<code>--net=host</code>来跳过虚拟网络直接使用主机IP</li><li>在主机级别的端口，一个端口只能被一个容器所监听</li></ul><h3 id=代码>代码</h3><ul><li><code>-p</code>命令后的格式是<code>HOST:CONTAINER</code></li><li><code>docker container port &lt;container></code>显示端口映射情况</li><li>查看容器地址<code>docker container inspect --format "{{ .NetworkSettings.IPAddress}}" &lt;container></code></li></ul><h3 id=命令行管理网络>命令行管理网络</h3><ul><li><code>docker network ls</code>列出所有虚拟网络<ul><li>bridge(docker0)是通过NAT防火墙连接至主机物理网络的默认网络</li><li>host是跳过docker的直接与主机网络接口连接的网络，牺牲了容器模式下的安全性换来了更高的网络性能</li><li>none:不与任何外部接口相连（eth0），只留有容器内部的localhost接口</li></ul></li><li><code>docker network inspect bridge</code>查看bridge网络的详情<ul><li>可以看到有哪些容器连接在这个网络上</li><li><code>IPAM</code>可以看到网络设置，最后通过网关连接到主机物理网络</li></ul></li><li><code>docker network create &lt;name></code>使用bridge的驱动（默认的）创建一个虚拟网络</li><li>启动（run）容器时可以用<code>--network</code>来指定网络</li><li><code>docker network connect/disconnect &lt;network> &lt;container></code>将容器连接至/断开网络连接</li></ul><h3 id=dns>DNS</h3><p>dcoker自带一个DNS用来解析域名（容器名）从而访问到正确的容器（使用相当于hostname的container name来实现容器之间的通讯）</p><ul><li>新建一个虚拟网络，当使用<code>--network</code>来将不通的容器连接至虚拟网络时，或自动以容器名为key来建立DNS服务，这样同一个虚拟网络之间的容器就可以互相连通</li><li>默认的<code>bridge</code>虚拟网络没有这种服务，每次添加新的容器如果需要与其他容器连接则需要手动使用<code>--link &lt;list of container></code>来设置</li></ul><h1 id=section4-image>Section4 Image</h1><h2 id=什么是image-包括>什么是Image （包括）</h2><ul><li>应用的二进制和依赖文件数据</li><li>image data的元数据和如何运行image的设定参数</li></ul><h2 id=image-layers>Image layers</h2><ul><li><p><code>docker image history</code> 显示Image layer的历史</p><ul><li>除了第一个履历有Image ID之外其他都为, 因为其他的layer只是构成Image的一部分并不是Image本身，所以不配拥有ID。</li></ul></li><li><p>每个Image都从成为scratch的空layer开始，在这之后发生在Image的文件系统中的改变都是一个layer
<img src=https://github.com/ACGNM/pics/raw/master/docker/image_layers.png alt=例图>
<img src=https://github.com/ACGNM/pics/raw/master/docker/custom_image.png alt=例图>
<img src=https://github.com/ACGNM/pics/raw/master/docker/copy_on_write.png alt=pic></p></li><li><p><code>docker image inspect</code> 取得Image的metadata (Image如何运行，Image的JSON格式的详细信息)</p></li></ul><h2 id=image-tag>image tag</h2><ul><li><code>dokcer image tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</code><ul><li><code>docker image tag --help</code>来查看用法</li><li>根据SOURCE_IMAGE(with tag <code>TAG</code>)来创建一个TARGET_IMAGE（默认tag为latest）</li><li>总是创建一个新记录（对于执行 <code>docker image ls</code>的结果）</li></ul></li><li>只是一个用来区分的名称。如nginx的latest和mainline是拥有同一个image ID的image。都pull下来时，pull第二个会显示已经存在。但是在<code>docker image ls</code>中分开显示（同时可以发现两者image ID相同）</li><li>默认的tag是<code>latest</code>。但并不代表就是最新的</li><li><code>docker image push</code>可以向Docker Hub上传变更过layer的image<ul><li>这之前需要先登陆。使用<code>docker login</code></li><li>在<code>./docker/config.json</code>中存储docker Hub的认证信息
如果想上传一个私人（private）的image，则先需要建立一个私人仓库然后再上传</li></ul></li></ul><h2 id=dockerfile基础>Dockerfile基础</h2><h3 id=参考dockerfile-sample-1注释>参考dockerfile-sample-1注释</h3><ul><li><a href=https://github.com/BretFisher/udemy-docker-mastery/blob/main/dockerfile-sample-1/Dockerfile>dockerfile-sample-1</a></li><li><a href=https://docs.docker.com/engine/reference/builder/#usage>官方相关文档</a></li></ul><h3 id=建立image-building-image>建立Image (building Image)</h3><ul><li>首先改变当前目录至存在<code>Dockerfile</code>的目录中<ul><li>如果想使用非默认名称 (Dockerfile) 的dockerfile, 使用<code>-f</code>选项 (<code>docker image build -f &lt;dockerfile_name></code>)</li></ul></li><li><code>docker image build -t IMAGE_NAME[:TAG] &lt;path></code><ul><li>如果只是本地使用，则不需要在前面加上Docker Hub的account name</li></ul></li><li>接下来的输出对应Dockerfile的每一个stanza的命令<ul><li>每一步会对应一个存在build Cache中的Hash用来标记每一步</li><li>如果下一次build时Dockerfile的对应那一行没有变化则不会再执行一边相同的stanza</li><li>如果有所该表则重新执行有变化的stanza及其之后的所有stanza</li><li>Docker的build快速是因为docker将每一步都放入缓存中</li></ul></li><li>扩展官方image<ul><li>使用 <a href=https://github.com/BretFisher/udemy-docker-mastery/blob/main/dockerfile-sample-2>dockerfile-sample-2</a></li><li>可以直接<code>FROM</code>官方的Image来加入自定义设置</li><li>可以继承来<code>FROM</code>里的所有stanza，所以不需要加入<code>CMD</code>等必要的stanza</li><li><code>WORKDIR</code>相当于执行了<code>cd</code>命令</li><li><code>docker conainer run</code>的<code>-rm</code>flag用来告诉docker，当container退出后clean up container和其file system</li></ul></li></ul><ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://acgnm.github.io/techBlog/>&copy; Day Day Up 2021</a><div></div></div></footer></body></html>